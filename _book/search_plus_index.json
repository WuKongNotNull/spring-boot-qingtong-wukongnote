{"./":{"url":"./","title":"首页","keywords":"","body":"Introduction 大家好， 该文档定位`Spring Boot`初学者， 主要帮助大家快速入门，故称为「青铜篇」。 一级标题 测试内容 一级标题 测试内容 二级标题 测试内容 三级标题 测试内容 四级标题 测试内容 五级标题 测试内容 六级标题 测试内容 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/ 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 16:58:16 "},"introduction/introduction.html":{"url":"introduction/introduction.html","title":"开发入门","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/introduction.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 18:45:45 "},"introduction/maven-build.html":{"url":"introduction/maven-build.html","title":"maven 构建项目","keywords":"","body":"使用maven方式构建Spring Boot项目 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/maven-build.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:34:36 "},"introduction/initialzr-build.html":{"url":"introduction/initialzr-build.html","title":"Spring Initialzr 构建项目","keywords":"","body":"使用Spring Initialzr方式构建Spring Boot 项目 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/initialzr-build.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:34:00 "},"introduction/unit-test.html":{"url":"introduction/unit-test.html","title":"单元测试","keywords":"","body":"单元测试 案例 pom org.springframework.boot spring-boot-starter-test test test @SpringBootTest class MySpringbootApplicationTests { @Autowired private HelloController helloController; @Test public void contextLoads() { String hello = helloController.hello(); System.out.println(hello); } } # var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/unit-test.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:24:43 "},"introduction/hot-deploy.html":{"url":"introduction/hot-deploy.html","title":"热部署","keywords":"","body":"实操 pom文件钟添加spring-boot-devtools热部署依赖 org.springframework.boot spring-boot-devtools idea中热部署设置 第1步 第2步 ctrl+shift+alt(option)+/ 打开界面 热部署测试 使用浏览器测试，不需要重复启动main方法 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/hot-deploy.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:30:14 "},"introduction/dependency-management.html":{"url":"introduction/dependency-management.html","title":"依赖管理","keywords":"","body":"依赖管理 对依赖进行统一管理 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/dependency-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:31:11 "},"introduction/auto-config.html":{"url":"introduction/auto-config.html","title":"自动配置 ","keywords":"","body":"Spring Boot 自动配置 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/auto-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:35:44 "},"introduction/execute-flow.html":{"url":"introduction/execute-flow.html","title":"执行流程","keywords":"","body":"Spring Boot 执行流程 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/execute-flow.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:33:23 "},"config-annotation/config-annotation.html":{"url":"config-annotation/config-annotation.html","title":"核心配置与注解","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/config-annotation.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 18:49:20 "},"config-annotation/application-config.html":{"url":"config-annotation/application-config.html","title":"application 配置文件","keywords":"","body":"application.properties配置文件 #配置端口号 server.port=8090 #配置虚拟路径 server.servlet.context-path=/project-name application.yaml配置文件 #端口号 虚拟路径 server: port: 8091 servlet: context-path: /project-name2 注意 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/application-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:32:27 "},"config-annotation/inject-property.html":{"url":"config-annotation/inject-property.html","title":"属性注入","keywords":"","body":"使用注解@ConfigurationProperties和@Value注入属性 第一种方法properties #给属性赋值 person.id=2 person.name=xiaowang person.hobby=eat,drink,play person.family=father,mother person.map.k1=v1 person.map.k2=v2 person.peter.peterName=wangcai person.peter.peterAge=10 第二种方式yml #给属性赋值 person: id: 1 name: zhangsan hobby: [eat,drink,play] family: [baba,mama,gege,jiejie] map: {k1: v1,k2: v2} peter: {peterName: dog,peterAge: 2} 编写实体类,使用@Component,@ConfigurationProperties注解 package com.wukongnotnull.myspringboot.domain; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.context.annotation.PropertySource; import org.springframework.stereotype.Component; import java.util.Arrays; import java.util.List; import java.util.Map; /** * @Author: 悟空非空也（公众号/B站/知乎） */ @Component//生成当前类的实例对象，存到ioc容器中 @ConfigurationProperties(prefix = \"person\")//将配置文件中前缀为person的属性值映射到当前类的变量上 public class Person { private int id; private String name; private List hobby; private String[] family; private Map map; private Peter peter; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List getHobby() { return hobby; } public void setHobby(List hobby) { this.hobby = hobby; } public String[] getFamily() { return family; } public void setFamily(String[] family) { this.family = family; } public Map getMap() { return map; } public void setMap(Map map) { this.map = map; } public Peter getPeter() { return peter; } public void setPeter(Peter peter) { this.peter = peter; } @Override public String toString() { return \"Person{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", hobby=\" + hobby + \", family=\" + Arrays.toString(family) + \", map=\" + map + \", peter=\" + peter + '}'; } } package com.wukongnotnullg.myspringboot.domain; /** * @Author: 悟空非空也（公众号/B站/知乎） */ public class Peter { private String peterName; private int peterAge; public String getPeterName() { return peterName; } public void setPeterName(String peterName) { this.peterName = peterName; } public int getPeterAge() { return peterAge; } public void setPeterAge(int peterAge) { this.peterAge = peterAge; } @Override public String toString() { return \"Peter{\" + \"peterName='\" + peterName + '\\'' + \", peterAge=\" + peterAge + '}'; } } 测试类 @SpringBootTest class MySpringbootApplicationTests { @Autowired private Person person; @Autowired private HelloController helloController; @Value(value = \"${person.name}\") //直接注入，不需要setter方法 private String str; @Test public void contextLoads() { String hello = helloController.hello(); System.out.println(hello); } @Test public void personTest(){ System.out.println(person); } @Test public void strTest(){ System.out.println(\"打印出str===》\"+str); } } @Value直接注入属性 #给基本数据数据类型注入 str=jibenshujuleixing 测试 @SpringBootTest class MySpringbootApplicationTests { @Value(value = \"${str}\") //直接注入，不需要setter方法 private String str; @Test public void strTest(){ System.out.println(\"打印出str===》\"+str); } } @ConfigurationProperties注解支持JSR303数据校验 application.properties #@ConfigurationProperties注解支持JSR303数据校验 user.email=139aaaa 实体类 package com.wukongnotnullg.myspringboot.domain; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import org.springframework.validation.annotation.Validated; import javax.validation.constraints.Email; @Component @ConfigurationProperties(prefix = \"user\") @Validated public class User { @Email private String email; public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } } pom org.springframework.boot spring-boot-starter-validation test @Test public void validateTest(){ System.out.println(user.getEmail()); } 两种注解对比分析 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/inject-property.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:32:50 "},"config-annotation/custom-config.html":{"url":"config-annotation/custom-config.html","title":"自定义配置","keywords":"","body":"使用 @PropertySource 加载自定义配置文件 自定义配置文件test.properties #自定义配置文件 test.id=1 test.name=testzhangsan 实体类 package com.wukongnotnull.myspringboot.domain; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import org.springframework.stereotype.Component; /** * @Author: 悟空非空也（公众号/B站/知乎） */ //注意：可以使用@Component代替 //@Configuration+@EnableConfigurationProperties(MyProperties.class) @Configuration//指定当前类为配置类， @PropertySource(\"classpath:test.properties\")//指定自定义配置文件的来源 @EnableConfigurationProperties(MyProperties.class)//开启配置文件的属性注入功能 @ConfigurationProperties(prefix = \"test\") public class MyProperties { private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"MyProperties{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } } 测试 @SpringBootTest class MySpringbootApplicationTests { @Autowired private MyProperties myProperties; @Test public void myPropertiesTest(){ System.out.println(\"myProperties===>\"+myProperties); } } 使用@ImportResource加载自定义的xml配置文件(不推荐使用) 创建xml配置文件 启动类上添加@ImportResource注解 package com.siliang.myspringboot; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ImportResource; @SpringBootApplication @ImportResource(\"classpath:bean.xml\") public class MySpringbootApplication { public static void main(String[] args) { SpringApplication.run(MySpringbootApplication.class, args); } } test @SpringBootTest class MySpringbootApplicationTests { //此处注入的是这个类 @Autowired private ApplicationContext applicationContext; @Test public void myServiceTest(){ MyService myService = (MyService)applicationContext.getBean(\"myService\"); System.out.println(myService); } 使用@Configuration编写自定义配置类 编写配置类 package com.siliang.myspringboot.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @Author: 悟空非空也（公众号/B站/知乎） */ @Configuration //定义该类为 配置类 public class MyConfig { @Bean(name = \"myService2\") public MyService getMyService(){ return new MyService(); } } public class MyService { } 测试 @Autowired private ApplicationContext applicationContext; @Test public void myServiceTest(){ MyService myService = (MyService)applicationContext.getBean(\"myService2\"); System.out.println(myService); } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/custom-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:32:40 "},"config-annotation/profile-config.html":{"url":"config-annotation/profile-config.html","title":"profile 文件配置","keywords":"","body":"使用profile文件进行多环境配置 多环境配置文件格式 方法一：使用命令行方式激活指定环境的配置文件 ctrl+c 服务器运行退出 ctrl+c 停止 方法二：在全局配置文件application.properties设置 spring.profiles.active属性激活 spring.profiles.active=test 2.9 使用@Profile注解进行多环境配置 编写不同环境下的配置类 package com.siliang.config; /** * @Author: 悟空非空也（公众号/B站/知乎） */ public interface DBConnector { public void configuration(); } package com.siliang.config; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; /** * @Author: 悟空非空也（公众号/B站/知乎） */ @Configuration @Profile(value =\"developer\" ) public class DeveloperDBConnector implements DBConnector { @Override public void configuration() { System.out.println(\"开发环境===>连接数据库\"); } } package com.siliang.config; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; /** * @Author: 悟空非空也（公众号/B站/知乎） */ @Configuration @Profile(value = \"product\") public class ProductDBConnector implements DBConnector { @Override public void configuration() { System.out.println(\"生产环境====》连接数据库\"); } } package com.siliang.config; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; /** * @Author: 悟空非空也（公众号/B站/知乎） */ @Configuration @Profile(value = \"test\") public class TestDBConnector implements DBConnector { @Override public void configuration() { System.out.println(\"测试环境下===》连接数据库\"); } } 在全局配置文件application.properties中指定使用哪个环境 spring.profiles.active=test #或者 #spring.profiles.active=product #或者 #spring .profiles.active=develop 测试 @Autowired private DBConnector dbConnector; @Test public void dbConnectorTest(){ dbConnector.configuration(); } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/profile-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:20:33 "},"config-annotation/property-reference.html":{"url":"config-annotation/property-reference.html","title":"随机值设置及参数引用","keywords":"","body":"参数间引用 application.properties #参数间的引用 app.name=shopping app.description=${app.name} is a buying spring boot application jack.age=${random.int[10,20]} jack.description=jack 的年龄 可能是 ${jack.age} test @SpringBootTest class MySpringboot2ApplicationTests { @Value(\"${jack.description}\") private String str; @Test void contextLoads() { System.out.println(str); } } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/property-reference.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:33:41 "},"data-access/data-access.html":{"url":"data-access/data-access.html","title":"数据访问","keywords":"","body":"Spring Boot 数据访问概述 # var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/data-access.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:49:19 "},"data-access/env-setup.html":{"url":"data-access/env-setup.html","title":"环境搭建","keywords":"","body":"基础环境搭建 创建数据库 CREATE DATABASE springbootdata; USE springbootdata; CREATE TABLE `t_article` ( `id` INT(20) NOT NULL AUTO_INCREMENT COMMENT '文章id', `title` VARCHAR(200) DEFAULT NULL COMMENT '文章标题', `content` LONGTEXT COMMENT '文章内容', PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; INSERT INTO `t_article` VALUES ('1', 'Spring Boot基础入门', '从入门到精通讲解...'); INSERT INTO `t_article` VALUES ('2', 'Spring Cloud基础入门', '从入门到精通讲解...'); CREATE TABLE `t_comment` ( `id` INT(20) NOT NULL AUTO_INCREMENT COMMENT '评论id', `content` LONGTEXT COMMENT '评论内容', `author` VARCHAR(200) DEFAULT NULL COMMENT '评论作者', `a_id` INT(20) DEFAULT NULL COMMENT '关联的文章id', PRIMARY KEY (`id`) ) ENGINE=INNODB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; INSERT INTO `t_comment` VALUES ('1', '很全、很详细', '鲁迅', '1'); INSERT INTO `t_comment` VALUES ('2', '赞一个', 'tom', '1'); INSERT INTO `t_comment` VALUES ('3', '很详细', 'kitty', '1'); INSERT INTO `t_comment` VALUES ('4', '很好，非常详细', '张三', '1'); INSERT INTO `t_comment` VALUES ('5', '很不错', '李四', '2'); 创建项目，引入mysql和mybatis的依赖启动器 创建实体类domain package com.wukongnotnul.myspringbootmybatis.domain; import java.util.List; public class Article { private Integer id; private String title; private String content; //额外增加一个字段 评论集合 private List commentList; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getTitle() { return title; } public void setTitle(String title) { this.title = title; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public List getCommentList() { return commentList; } public void setCommentList(List commentList) { this.commentList = commentList; } } package com.wukongnotnull.myspringbootmybatis.domain; public class Comment { private Integer id; private String content; private String author; private Integer aId;//此属性名和表中的字段a_id不一致，不能自动映射，需要在application.properties中进行配置 mybatis.configuration.map-underscore-to-camel-case=true public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public Integer getaId() { return aId; } public void setaId(Integer aId) { this.aId = aId; } } 全局配置文件进行数据库连接配置 spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/springbootdata?serverTimezone=UTC spring.datasource.username=root spring.datasource.password=root 设置数据源类型配置（ali的druid数据源为例） com.alibaba druid-spring-boot-starter 1.1.22 在全局配置文件中设置druid的属性 spring.datasource.type = com.alibaba.druid.pool.DruidDataSource spring.datasource.initialSize=20 spring.datasource.minIdle=10 spring.datasource.maxActive=100 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/env-setup.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:52:50 "},"data-access/integrate-mybatis.html":{"url":"data-access/integrate-mybatis.html","title":"整合 MyBatis","keywords":"","body":"使用注解的方式整合MyBatis mapper接口 package com.wukongnotnull.mapper; import com.wukongnotnull.domain.Comment; import org.apache.ibatis.annotations.*; //表示该类是mybatis接口文件，需要被springboot扫描 @Mapper public interface CommentMapper { //查询 @Select(\"select * from t_comment where id=#{id}\") public Comment getCommentById(@Param(\"id\") Integer id); //增加 @Insert(\"insert into t_comment(content,author,a_id)values(#{content},#{author},#{aId})\") public int addComment(Comment comment); //修改 @Update(\"update t_comment set content=#{content},author=#{author},a_id=#{aId} where id=#{id}\") public int modifyComment(Comment comment); //删除 @Delete(\"delete from t_comment where id=#{id}\") public int deleteComment(@Param(\"id\") Integer id); } 测试 package com.siliang; import com.siliang.domain.Comment; import com.siliang.mapper.CommentMapper; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import javax.annotation.Resource; @SpringBootTest class MyspringbootMybatisApplicationTests { //此处使用@Autowired也可以，但是会标红 @Resource private CommentMapper commentMapper; private Comment comment=new Comment(); @Test void selectTest() { Comment comment = commentMapper.getCommentById(1); System.out.println(comment); } @Test void addTest(){ comment.setContent(\"this article is very good\"); comment.setAuthor(\"libai\"); comment.setaId(1); int i = this.commentMapper.addComment(comment); System.out.println(\"add====>\"+i); } @Test void updateTest(){ comment.setId(1); comment.setContent(\"这部书太恐怖\"); comment.setAuthor(\"libai2\"); comment.setaId(1); int i = this.commentMapper.modifyComment(comment); System.out.println(\"update====>\"+i); } @Test void deleteTest(){ int i = this.commentMapper.deleteComment(6); System.out.println(\"delete===>\"+i); } } 使用配置文件的方式整合MyBatis 在全局配置文件配置 #配置mybatis的xml配置文件路径 mybatis.mapper-locations=classpath:mapper/** #配置xml配置文件中实体类的别名 mybatis.type-aliases-package=com.siliang.domain 编写ArticleMapper接口 package com.siliang.mapper; import com.siliang.domain.Article; import org.apache.ibatis.annotations.Mapper; @Mapper public interface ArticleMapper { //查询 public Article getArticleById(Integer id); } 编写接口对应的xml配置文件 SELECT a.*,c.`id` AS c_id,c.`content` as c_content,c.`author`,c.`a_id` FROM t_article a,t_comment c WHERE a.`id`=c.`a_id` AND a.`id`=#{id} 测试 package com.siliang; import com.siliang.domain.Article; import com.siliang.mapper.ArticleMapper; import org.junit.jupiter.api.Test; import org.springframework.boot.test.context.SpringBootTest; import javax.annotation.Resource; @SpringBootTest public class ArticleTest { @Resource private ArticleMapper articleMapper; @Test void selectTest(){ Article article = articleMapper.getArticleById(1); System.out.println(article); } } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/integrate-mybatis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:54:10 "},"data-access/integrate-jpa.html":{"url":"data-access/integrate-jpa.html","title":"整合 JPA","keywords":"","body":"Spring Date JPA介绍 3.6使用Spring Boot整合JPA var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/integrate-jpa.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:54:35 "},"data-access/integrate-redis.html":{"url":"data-access/integrate-redis.html","title":"整合 Redis","keywords":"","body":"Redis介绍 什么是Redis Redis 是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件，并提供多种语言的API。 优点 1.存取速度快：Redis速度非常快，每秒可执行大约110000次的设值操作，或者执行81000次的读取操作。 2.支持丰富的数据类型：Redis支持开发人员常用的大多数数据类型，例如列表、集合、排序集和散列等。 3.操作具有原子性：所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新后的值。 4.提供多种功能：Redis提供了多种功能特性，可用作非关系型数据库、缓存中间件、消息中间件等。 redis下载与安装 下载路径 https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100 解压后放入磁盘某位置就安装成功（免安装） 安装可视化客户端 使用Spring Boot整合Redis 1.在pom文件中添加Spring Data Redis依赖启动器 org.springframework.boot spring-boot-starter-data-redis 2.在全局配置文件application.properties中添加Redis数据库连接配置 spring.redis.host=127.0.0.1 spring.redis.port=6379 spring.redis.password= 3.编写实体类 @RedisHash(\"persons\") public class Person { @Id private String id; //主键是string类型 @Indexed private String firstname; @Indexed private String lastname; private Address address; private List familyList;//家人 } public class Address { @Indexed private String city; @Indexed private String country; } public class Family { @Indexed private String type; @Indexed private String username;} 4.编写Repository接口 public interface PersonRepository extends CrudRepository {//（实体类，主键类型） List findByLastname(String lastname); Page findPersonByLastname(String lastname, Pageable page); List findByFirstnameAndLastname(String firstname, String lastname); List findByAddress_City(String city); List findByFamilyList_Username(String username); } 5.编写单元测试进行接口方法测试以及整合测试 @Autowired public PersonRepository personRepository; @Test public void selectPerson() { List list = repository.findByAddress_City(\"北京\"); System.out.println(list); @Test void addTest(){ Person person=new Person(); person.setId(\"p001\"); Address address = new Address(); address.setCity(\"江苏省\"); address.setCountry(\"南京市\"); person.setAddress(address); List familyList=new ArrayList<>(); Family family=new Family(); family.setType(\"father\"); family.setUsername(\"杨康\"); Family family2=new Family(); family2.setType(\"mother\"); family2.setUsername(\"穆念慈\"); familyList.add(family); familyList.add(family2); person.setFamilyList(familyList); person.setLastName(\"杨\"); person.setFirstName(\"过\"); Person person1 = personRepository.save(person); System.out.println(\"person1=====>\"+person1); } } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/integrate-redis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 20:55:45 "},"view-tech/view-tech.html":{"url":"view-tech/view-tech.html","title":"支持视图技术","keywords":"","body":"Spring Boot 支持的视图技术 # var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/view-tech/view-tech.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 21:14:31 "},"view-tech/thymeleaf.html":{"url":"view-tech/thymeleaf.html","title":"thymeleaf","keywords":"","body":"Thymeleaf常用标签 Thymeleaf 标准表达式 Thymeleaf 基本使用 创建springboot项目 org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 配置thymeleaf模板缓存application.properties #模板缓存 spring.thymeleaf.cache=true #模板编码 spring.thymeleaf.encoding=UTF-8 #模板样式 spring.thymeleaf.mode=HTML5 #指定模板存放路径 spring.thymeleaf.prefix=classpath:/templates/ #指定模板页面的后缀 spring.thymeleaf.suffix=.html 4.5 使用Thymeleaf 完成数据的页面展示 #模板缓存改成false，上线后改成true spring.thymeleaf.cache=false controller package com.siliang.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping; import java.util.Calendar; @Controller public class LoginController { @RequestMapping(value = \"/login\") public String login(Model model){ int currentYear = Calendar.getInstance().get(Calendar.YEAR); model.addAttribute(\"currentYear\",currentYear); return \"login\"; } } login.html 用户登录界面 请登录 [[#{login.rememberme}]] 登录 © 2018-2019 中文 English 4.6 使用Thymeleaf配置国际化页面 login.properties login.tip=请登录 login.username=用户名 login.password=密码 login.rememberme=记住我 login.button=登录 login_zh_CN.properties login.tip=请登录 login.username=用户名 login.password=密码 login.rememberme=记住我 login.button=登录 login_en_US.properties login.tip=Please sign in login.username=Username login.password=Password login.rememberme=Remember me login.button=Login 在application.properties中配置国际化文件的基础名 #配置国际化文件基础名 spring.messages.basename=i18n.login 定制区域化解析器 package com.wukongnotnull.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.lang.Nullable; import org.springframework.util.StringUtils; import org.springframework.web.servlet.LocaleResolver; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; @Configuration public class MyLocaleResolver implements LocaleResolver { // 自定义区域解析方式 @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) { // 获取页面手动切换传递的语言参数l String l = httpServletRequest.getParameter(\"l\"); // 获取请求头自动传递的语言参数Accept-Language String header = httpServletRequest.getHeader(\"Accept-Language\"); Locale locale=null; // 如果手动切换参数不为空，就根据手动参数进行语言切换，否则默认根据请求头信息切换 if(!StringUtils.isEmpty(l)){ String[] split = l.split(\"_\"); locale=new Locale(split[0],split[1]); }else { // Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 String[] splits = header.split(\",\"); String[] split = splits[0].split(\"-\"); locale=new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, @Nullable HttpServletResponse httpServletResponse, @Nullable Locale locale) { } // 将自定义的MyLocaleResolver类重新注册为一个类型LocaleResolver的Bean组件 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } } 启动后，浏览器测试 还是出现中文乱码 原因 解决方案 最佳方案 在创建新项目前，将idea进行字符编码设置，这样保证项目和配置文件中的所有中文打字都是使用utf-8编码 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/view-tech/thymeleaf.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 21:37:13 "},"web-dev/web-dev.html":{"url":"web-dev/web-dev.html","title":"实现 Web 开发","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/web-dev.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 08:55:14 "},"web-dev/integrate-mvc.html":{"url":"web-dev/integrate-mvc.html","title":"整合 MVC","keywords":"","body":"Spring MVC的整合支持 自定义拦截器组件 package com.wukongnotnull.interceptor; import com.wukongnotnull.tools.Constants; import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import org.springframework.web.servlet.ModelAndView; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Calendar; @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { String requestURI = request.getRequestURI(); Object loginUser = request.getSession().getAttribute(Constants.USER_SESSION); //请求路径是/admin的时候（同时session为null），拦截器放行通过 if(requestURI.startsWith(\"/admin\") && loginUser==null){ response.sendRedirect(request.getContextPath()+\"/toLoginPage\"); return false; } return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { int currentYear = Calendar.getInstance().get(Calendar.YEAR); request.setAttribute(\"currentYear\",currentYear); } } 编写自定义配置类，实现WebMvcConfigurer package com.siliang.config; import com.siliang.interceptor.MyInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/toLoginPage\").setViewName(\"login\"); registry.addViewController(\"/login.html\").setViewName(\"login\"); } @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { //对/** 格式的请求路径进行拦截，排除/login.html registry.addInterceptor(myInterceptor).addPathPatterns(\"/**\").excludePathPatterns(\"/login.html\"); } } 测试 localhost:8080/admin 可以正常显示 年份（经过拦截器并放行） localhost:8080/login.html 不能显示年份（因没有经过拦截器） var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/integrate-mvc.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 09:01:41 "},"web-dev/integrate-servlet.html":{"url":"web-dev/integrate-servlet.html","title":"整合 Servlet 三大组件","keywords":"","body":"5.2组件注册整合Servlet三大组件 5.3路径扫描整合Servlet三大组件 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/integrate-servlet.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 09:02:19 "},"web-dev/file-upload.html":{"url":"web-dev/file-upload.html","title":"文件上传","keywords":"","body":"文件上传 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/file-upload.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 09:02:46 "},"web-dev/file-download.html":{"url":"web-dev/file-download.html","title":"文件下载","keywords":"","body":"文件下载 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/file-download.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 09:02:32 "},"web-dev/jar-package.html":{"url":"web-dev/jar-package.html","title":"jar 打包部署","keywords":"","body":"jar包方式打包部署 maven打包插件 org.springframework.boot spring-boot-maven-plugin 点击package 保存路径 部署后就可以访问 java -jar target\\myspringboot-mybatis-0.0.1-SNAPSHOT.jar 注意 使用 java 指令，需要配置java的环境变量 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/jar-package.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 09:03:40 "},"web-dev/war-package.html":{"url":"web-dev/war-package.html","title":"war 打包部署","keywords":"","body":"war包方式打包部署 1 war 1.2 2 @SpringBootApplication public class MyspringbootMybatisApplication extends SpringBootServletInitializer { //继承SpringbootServletInitializer ,重写configure方法 protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(MyspringbootMybatisApplication.class); } public static void main(String[] args) { SpringApplication.run(MyspringbootMybatisApplication.class, args); } } 3打包 4部署到外部的tomcat的webapp内 5 启动tomcat，部署成功 bin\\startup.bat指令 注意 一个既有前端又有后端的web项目，jar包不包含前端文件（jsp\\html\\css\\img等），war包包含所有 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/war-package.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 09:06:27 "},"cache-management/cache-management.html":{"url":"cache-management/cache-management.html","title":"缓存管理","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/cache-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 10:00:06 "},"cache-management/env-setup.html":{"url":"cache-management/env-setup.html","title":"基础环境搭建","keywords":"","body":"基础环境搭建 创建项目 配置文件配置 #mysql数据库连接配置 #spring.datasource.driver-class-name=com.mysql.jdbc.Driver spring.datasource.url=jdbc:mysql://localhost:3306/springbootdata?serverTimezone=UTC spring.datasource.username=root spring.datasource.password=root #显示使用JPA进行数据库查询 spring.jpa.show-sql=true 实体类 package com.wukongnotnull.domain; import javax.persistence.*; @Entity(name = \"t_comment\") public class Comment { @Id//注意导包 javax.persistence.Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String content; private String author; @Column(name = \"a_id\")//实现映射 private Integer aId;//此属性名和表中的字段a_id不一致，不能自动映射，需要在application.properties中进行配置 public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public Integer getaId() { return aId; } public void setaId(Integer aId) { this.aId = aId; } } 编写自定义仓库类，继承JpaRepository package com.wukongnotnull.repository; import com.wukongnotnull.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import org.springframework.transaction.annotation.Transactional; //接口遵循jpa的规则 public interface CommentRepository extends JpaRepository { //modify comment according id and author @Transactional//进行事务管理 @Modifying @Query(\"update t_comment c set c.author=?1 where c.id=?2\") public int updateComment(String author,Integer id); } service层 package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import java.util.Optional; public interface CommentService { //add public Comment addComment(Comment comment); //delete public void deleteComment(Integer id); //modify public int modifyComment(Integer id,String author); //query public Comment findById(Integer id); } package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); } //query public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } controller层 package com.wukongnotnull.controller; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.service.CommentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class CommentController { @Autowired private CommentService commentService; //query @GetMapping(\"/query/{id}\") public Comment findById(@PathVariable(\"id\") Integer id){ return this.commentService.findById(id); } //modify @GetMapping(\"/modify/{id}/{author}\") public int modifyBy(@PathVariable(\"id\") Integer id,@PathVariable(\"author\") String author){ int i = this.commentService.modifyComment(id, author); return i; } //delete @GetMapping(\"/delete/{id}\") public void deleteById(@PathVariable(\"id\") Integer id){ this.commentService.deleteComment(id); } //add } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/env-setup.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 10:09:58 "},"cache-management/default-cache.html":{"url":"cache-management/default-cache.html","title":"默认缓存","keywords":"","body":"Spring Boot默认缓存体验 spring boot 自带缓存机制，可以使用默认缓存，避免每次查询都去数据库访问一边，避免资源消耗 在启动类上添加注解@EnableCache package com.wukongnotnull; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; @SpringBootApplication @EnableCaching//开启springboot默认缓存 public class RedisSprongbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSprongbootApplication.class, args); } } 在service层的实现类上添加注解@Cacheable，开辟缓存空间 package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); } //query @Cacheable(cacheNames = \"comment\")//创建缓存空间，并命名为comment public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } 测试，多次查询，在控制台只打印第一次查询日志 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/default-cache.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 10:05:35 "},"cache-management/integrate-redis.html":{"url":"cache-management/integrate-redis.html","title":"redis 缓存","keywords":"","body":"Spring Boot 缓存注解介绍 基于注解的Redis缓存实现 pom中添加redis的依赖启动器 org.springframework.boot spring-boot-starter-data-redis 配置redis的连接配置 #redis数据库的连接配置 spring.redis.host=127.0.0.1 spring.redis.port=6379 spring.redis.password= 启动类上添加注解@EnableCache @SpringBootApplication @EnableCaching//开启springboot默认缓存 public class RedisSprongbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSprongbootApplication.class, args); } } service层上对删改查操作添加redis缓存注解 增加功能直接插入mysql数据库 package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.CacheEvict; import org.springframework.cache.annotation.CachePut; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete @CacheEvict(cacheNames = \"comment\")//删除使用@CacheEvict public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify @CachePut(cacheNames = \"comment\",key =\"#result.id\")//更新使用，@CachePut,此处返回类型不能为int，因为缓存数据库中为int，再次查询需要的是Comment /* public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); }*/ public Comment modifyComment(Integer id,String author){//注意：key =\"#result.id\" 不是key =\"#result\" int i = this.commentRepository.updateComment(author, id); //再次查询操作,查询结果存入redis缓存中 return this.findById(id); } //query @Cacheable(cacheNames = \"comment\",unless = \"#result==null\")//创建缓存空间，并命名为comment,如果查询结果为null，不存入该空间 public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } 实体类序列化 @Entity(name = \"t_comment\") public class Comment implements Serializable { @Id//注意导包 javax.persistence.Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String content; private String author; @Column(name = \"a_id\")//实现映射 private Integer aId;//此属性名和表中的字段a_id不一致，不能自动映射，需要在application.properties中进行配置 6.5基于API的Redis缓存实现 @SpringBootApplication public class RedisSprongbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSprongbootApplication.class, args); } } 实体类Comment package com.wukongnotnull.domain; import javax.persistence.*; import java.io.Serializable; @Entity(name = \"t_comment\") public class Comment implements Serializable { @Id//注意导包 javax.persistence.Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String content; private String author; @Column(name = \"a_id\")//实现映射 private Integer aId;//此属性名和表中的字段a_id不一致，不能自动映射，需要在application.properties中进行配置 public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getContent() { return content; } public void setContent(String content) { this.content = content; } public String getAuthor() { return author; } public void setAuthor(String author) { this.author = author; } public Integer getaId() { return aId; } public void setaId(Integer aId) { this.aId = aId; } } repository:CommentRepository package com.wukongnotnull.repository; import com.wukongnotnull.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import org.springframework.transaction.annotation.Transactional; //接口遵循jpa的规则 public interface CommentRepository extends JpaRepository { //modify comment according id and author @Transactional//进行事务管理 @Modifying @Query(\"update t_comment set author=?1 where id=?2\") public int updateComment(String author,Integer id); } service: ApiCommentService package com.wukongnotnull.service; import ch.qos.logback.core.util.TimeUtil; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.Optional; import java.util.concurrent.TimeUnit; @Service @Transactional public class ApiCommentService { @Autowired private CommentRepository commentRepository; @Autowired private RedisTemplate redisTemplate; /** * 查询方法 */ public Comment findById(Integer id){ //先到缓存中查询 Comment comment = (Comment) redisTemplate.opsForValue().get(\"comment_\" + id); if(comment!=null){ //缓存中有数据 return comment; }else{//缓存中没有数据 //到数据库中进行查询 Optional byId = commentRepository.findById(id); if(byId.isPresent()){ //若是数据库中存在，将数据先存入redis Comment comment1 = byId.get(); redisTemplate.opsForValue().set(\"comment_\"+id,comment1,1, TimeUnit.DAYS); return comment1; } System.out.println(\"缓存中没有数据的情况下，数据库中也没有\"); return null; } } /** * 更新方法 */ public Comment updateComment(Comment comment){ //更新mysql数据库 int i = commentRepository.updateComment(comment.getAuthor(), comment.getId()); //更新redis缓存 redisTemplate.opsForValue().set(\"comment_\"+comment.getId(),comment); //更新后进行查询 return this.findById(comment.getId()); } /** * 删除方法 */ public void deleteComment(Integer id){ //删除数据库中的数据 commentRepository.deleteById(id); //删除redis缓存中的数据 redisTemplate.delete(\"comment_\" + id); } } controller:ApiCommentController package com.wukongnotnull.controller; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.service.ApiCommentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/api\") public class ApiCommentController { @Autowired private ApiCommentService apiCommentService; //query @GetMapping(\"/query/{id}\") public Comment findById(@PathVariable(\"id\") Integer id){ return this.apiCommentService.findById(id); } //modify @GetMapping(\"/modify/{id}/{author}\") public Comment modifyBy(@PathVariable(\"id\") Integer id,@PathVariable(\"author\") String author){ Comment comment = new Comment(); comment.setId(id); comment.setAuthor(author); return this.apiCommentService.updateComment(comment); } //delete @GetMapping(\"/delete/{id}\") public void deleteById(@PathVariable(\"id\") Integer id){ this.apiCommentService.deleteComment(id); } //add } 6.6自定义RedisTemplate(基于api的缓存数据json格式化) 痛点 缓存管理的实体类使用的jdk序列化机制，缺点：不便于可视化 缓存中的数据进行json序列化 对基于api的redis缓存有效，注解无效 package com.wukongnotnull.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.cache.RedisCacheConfiguration; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializationContext; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.time.Duration; @Configuration // 定义一个配置类 public class RedisConfig { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); // 使用JSON格式序列化对象，对缓存数据key和value进行转换 Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class); // 解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 设置RedisTemplate模板API的序列化方式为JSON template.setDefaultSerializer(jacksonSeial); return template; } 自定义RedisCacheManager（基于注解的缓存数据的json格式化） 基于注解的，基于api的无效，实体类可以删除ImplementSeriable 序列化 package com.wukongnotnull.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.cache.RedisCacheConfiguration; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializationContext; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.time.Duration; @Configuration//定义为配置类 public class RedisConfig { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { // 分别创建String和JSON格式序列化对象，对缓存数据key和value进行转换 RedisSerializer strSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class); // 解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 定制缓存数据序列化方式及时效 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofDays(1)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(strSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jacksonSeial)) .disableCachingNullValues(); RedisCacheManager cacheManager = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(config).build(); return cacheManager; } } # var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/integrate-redis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 10:09:25 "},"message-service/message-service.html":{"url":"message-service/message-service.html","title":"消息服务","keywords":"","body":"为什么要使用消息服务 在多数应用尤其是分布式系统中，消息服务是不可或缺的重要部分，它使用起来比较简单，同时解决了不少难题，例如异步处理、应用解耦、流量削锋、分布式事务管理等，使用消息服务可以实现一个高性能、高可用、高扩展的系统。 异步处理 应用解耦 流量削峰 分布式事务 1.订单支付成功后，写入消息表 2.定时扫描消息表消息写入到消息队列中 3.库存系统会立即读取到消息队列中的消息进行库存更新，同时添加消息处理状态 4.库存系统向消息队列中写入库存处理结果 5.订单系统会立即读取到消息队列中的库存处理状态。直接删除消息表数据，并写入到历史消息表 8.2 常用消息中间件介绍 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/message-service/message-service.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 17:03:26 "},"message-service/rabbitMQ.html":{"url":"message-service/rabbitMQ.html","title":"rabbitMQ 消息中间件","keywords":"","body":"RabbitMQ消息中间件 工作模式介绍 •Work queues（工作队列模式） •Publish/Subscribe（发布订阅模式） •Routing（路由模式） •Topics（通配符模式） •RPC •Headers（使用较少，不进行详细介绍） 8.4 安装RabbitMQ 注意版本的兼容，3.8版本需要20以上的，不然不兼容，注意 1、在RabbitMQ官网上http://www.rabbitmq.com/install-windows.html 下载,如果是在Windows环境下安装RabbitMQ消息中间件还需要64位的Erlang语言包支持。 2、 RabbitMQ安装包依赖于Erlang语言包的支持，所以要先安装Erlang语言包，再安装RabbitMQ安装包。 3、RabbitMQ可视化效果展示, RabbitMQ默认提供了两个端口号5672和15672，其中5672用作服务端口号，15672用作可视化管理端口号。在浏览器上访问http://localhost:15672(用户名和密码均为guest) 8.5 Spring Boot整合RabbitMQ环境搭建 1-pom org.springframework.boot spring-boot-starter-amqp org.springframework.boot spring-boot-starter-web 2-application.properties #连接rabbitmq服务器 spring.rabbitmq.host=localhost spring.rabbitmq.port=5672 spring.rabbitmq.username=guest spring.rabbitmq.password=guest #配置rabbitmq虚拟主机路径 / ，默认可以省略 spring.rabbitmq.virtual-host=/ 8.6 Public/Subscribe发布/订阅工作模式 1-基于api方式 1.1 交换器和队列进行绑定 @Autowired private AmqpAdmin amqpAdmin; @Test public void amqpAdmin(){ //定义fanout类型交换器 amqpAdmin.declareExchange(new FanoutExchange(\"fanout_exchange\")); //定义2个默认持久化队列，处理email和sms amqpAdmin.declareQueue(new Queue(\"fanout_queue_email\")); amqpAdmin.declareQueue(new Queue(\"fanout_queue_sms\")); //将队列分别与交换机进行绑定 amqpAdmin.declareBinding(new Binding(\"fanout_queue_email\", Binding.DestinationType.QUEUE,\"fanout_exchange\",\"\",null)); amqpAdmin.declareBinding(new Binding(\"fanout_queue_sms\",Binding.DestinationType.QUEUE, \"fanout_exchange\",\"\",null)); 1.2 消息发布者发布消息 先创建实体类，同时将实体类输出格式转换成json格式 package com.wukongnotnull.studyrabbitmq.domain; public class User { private Integer id; private String username; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } package com.wukongnotnull.studyrabbitmq.config; import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter; import org.springframework.amqp.support.converter.MessageConverter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { //将实体类转换成json格式呈现 @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } } 消息发布者 @Autowired private RabbitTemplate rabbitTemplate; @Test public void pushPublisher(){ User user = new User(); user.setId(1); user.setUsername(\"zhangsan\"); rabbitTemplate.convertAndSend(\"fanout_exchange\",\"\",user); } 1.3 消息消费者消费消息 package com.wukongnotnull.studyrabbitmq.service; import org.springframework.amqp.core.Message; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class RabbitMQService { @RabbitListener(queues = \"fanout_queue_email\") public void pushConsumerEmail(Message message){ byte[] bytes = message.getBody(); String string = new String(bytes); System.out.println(\"邮件业务接收到消息\"+string); } @RabbitListener(queues = \"fanout_queue_sms\") public void pushConsumerSMS(Message message){ byte[] bytes = message.getBody(); String string = new String(bytes); System.out.println(\"sms业务接收到消息\"+string); } } 1.4 测试 2-基于配置类的方式 1、打开RabbitMQ消息配置类RabbitMQConfig，定义消息转换器、fanout类型的交换器、不同名称的消息队列以及将不同名称的消息队列与交换器绑定。 package com.wukongnotnull.studyrabbitmq.config; import org.springframework.amqp.core.*; import org.springframework.amqp.support.converter.Jackson2JsonMessageConverter; import org.springframework.amqp.support.converter.MessageConverter; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class RabbitMQConfig { //将实体类转换成json格式呈现 @Bean public MessageConverter messageConverter(){ return new Jackson2JsonMessageConverter(); } //创建 fanout类型的交换器 @Bean public Exchange fanout_exchange(){ return ExchangeBuilder.fanoutExchange(\"fanout_exchange\").build(); } //创建 存放email消息的持久化队列 @Bean public Queue fanout_queue_email(){ return new Queue(\"fanout_queue_email\"); } //创建存放 sms 消息的持久化队列 @Bean public Queue fanout_queue_sms(){ return new Queue(\"fanout_queue_sms\"); } //创建存放 weixin 消息的持久化队列 @Bean public Queue fanout_queue_wx(){ return new Queue(\"fanout_queue_wx\"); } //email消息队列绑定交换机 @Bean public Binding bindingEmail(){ return BindingBuilder.bind(fanout_queue_email()).to(fanout_exchange()).with(\"\").noargs(); } //sms消息队列绑定交换机 @Bean public Binding bindingSms(){ return BindingBuilder.bind(fanout_queue_sms()).to(fanout_exchange()).with(\"\").noargs(); } //wx消息队列绑定交换机 @Bean public Binding bindingWx(){ return BindingBuilder.bind(fanout_queue_wx()).to(fanout_exchange()).with(\"\").noargs(); } } 3-基于注解方式实现 发布/订阅模式 package com.wukongnotnull.studyrabbitmq.service; import com.wukongnotnull.studyrabbitmq.domain.User; import org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class RabbitMQService { @RabbitListener(bindings =@QueueBinding(value = @Queue(\"fanout_queue_email\"), exchange = @Exchange(value = \"fanout_exchange\",type = \"fanout\"))) public void psubConsumerEmailAno(User user) { System.out.println(\"邮件业务接收到消息： \"+user); } @RabbitListener(bindings =@QueueBinding(value = @Queue(\"fanout_queue_sms\"),exchange = @Exchange(value = \"fanout_exchange\",type = \"fanout\"))) public void psubConsumerSmsAno(User user) { System.out.println(\"短信业务接收到消息： \"+user); } } 8.7 Routing路由工作模式 1.使用基于注解的方式定制消息组件和消息消费者 打开业务类RabbitMQService，在该类中使用@RabbitListener注解及其相关属性定制Routing路由模式的消息组件，并模拟编写消息消费者接收的方法。 package com.wukongnotnull.studyrabbitmq.service; import org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class RabbitMQService { @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \"routing_queue_error\"), exchange =@Exchange( value = \"routing_exchange\", type = \"direct\" ) , key = \"error_routing_key\" ) ) public void routingConsumerError(String message){ System.out.println(\"接收到error级别日志消息:\"+message); } @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \"routing_queue_all\"), exchange = @Exchange( value = \"routing_exchange\", type = \"direct\" ), key = {\"error_routing_key\",\"warning_routing_key\",\"info_routing_key\"} ) ) public void routingConsumerAll(String message){ System.out.println(\"接收到所有级别error,warning,info的日志消息:\"+message); } } 2.消息发送者发送消息 @Autowired private RabbitTemplate rabbitTemplate; @Test public void routingPublisher() { rabbitTemplate.convertAndSend(\"routing_exchange\", \"error_routing_key\", \"routing send : this is error message\"); } 3-测试结果 4-改造： 5-测试结果为： 8.8 Topics通配符工作模式 “通配符交换机”（Topic Exchange）将路由键和某模式进行匹配。此时队列需要绑定在一个模式上。符号“#”匹配一个或多个词，符号“”仅匹配一个词。因此“audit.#”能够匹配到“audit.irs.corporate”，但是“audit.”只会匹配到“audit.irs”。（这里与我们一般的正则表达式的“*”和“#”刚好相反，这里我们需要注意一下。） 举例： key: info.#.email.# 的队列 ---》邮件业务订阅该队列的消息 info.#.sms.# 的队列 ---》短信业务订阅该队列的消息 routingKey: info.emailinfo.sms info.email.sms 1-使用注解方式定制消息组件和消息订阅者（消费者） package com.wukongnotnull.studyrabbitmq.service; import org.springframework.amqp.rabbit.annotation.Exchange; import org.springframework.amqp.rabbit.annotation.Queue; import org.springframework.amqp.rabbit.annotation.QueueBinding; import org.springframework.amqp.rabbit.annotation.RabbitListener; import org.springframework.stereotype.Service; @Service public class RabbitMQService { @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \"topic_queue_email\"), exchange =@Exchange(value = \"topic_exchange\",type = \"topic\") , key = \"info.#.email.#\" )) public void topicConsumerEmail(String message){ System.out.println(\"邮件业务消费该消息：\"+message); } @RabbitListener( bindings = @QueueBinding( value = @Queue(value = \"topic_queue_sms\"), exchange = @Exchange(value = \"topic_exchange\",type = \"topic\"), key = \"info.#.sms.#\" ) ) public void topicConsumerSMS(String message){ System.out.println(\"短信业务消费该消息：\"+message); } } 2-消息发送者发送消息 @Autowired private RabbitTemplate rabbitTemplate; @Test public void topicPublisher(){ //只发邮件 // rabbitTemplate.convertAndSend(\"topic_exchange\",\"info.email\",\"email: this is an email\"); //只发短信 // rabbitTemplate.convertAndSend(\"topic_exchange\",\"info.sms\",\"sms: this is a sms\"); //既发邮件也发短信 rabbitTemplate.convertAndSend(\"topic_exchange\",\"info.email.sms\",\"both: we are an email and a sms\"); } # var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/message-service/rabbitMQ.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 17:08:19 "},"task-management/task-management.html":{"url":"task-management/task-management.html","title":"任务管理","keywords":"","body":"var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/task-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 17:11:56 "},"task-management/asynch-call.html":{"url":"task-management/asynch-call.html","title":"异步调用","keywords":"","body":"无返回值异步任务调用 1-application.java @EnableAsync //support async annotation @SpringBootApplication public class AsynChapter9Application { 2-service package com.wukongnotnull.asynchapter9.service; import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Service; @Service public class MyAsyncService { @Async public void sendSMS(){ System.out.println(\"send sms is progressing\"); long startTime = System.currentTimeMillis(); try { Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\"service --->the cost of total time is\"+(endTime-startTime)); } } 3-controller @RestController public class AsyncController { @Autowired private MyAsyncService myAsyncService; @RequestMapping(\"/sendSMS\") public String sendSMS(){ long startTime = System.currentTimeMillis(); myAsyncService.sendSMS(); long endTime = System.currentTimeMillis(); System.out.println(\" controller -->total time costs \"+(endTime-startTime)); return \"sms has been sent, wait for 10 seconds\"; } } 4-test 9.2 有返回值异步任务调用 1-sevice @Service public class MyAsyncService { @Async public Future processA(){ System.out.println(\"MyAsyncService-->start processA\"); long startTime = System.currentTimeMillis(); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } int count=123; long endTime = System.currentTimeMillis(); System.out.println(\"MyAsyncService-->processA end ,total time cost \"+(endTime-startTime)); return new AsyncResult(count); } @Async public Future processB(){ System.out.println(\"MyAsyncService-->start processB\"); long startTime = System.currentTimeMillis(); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } int count=321; long endTime = System.currentTimeMillis(); System.out.println(\"MyAsyncService-->processB end ,total time cost \"+(endTime-startTime)); return new AsyncResult(count); } 2-controller @RequestMapping(\"/statistics\") public String statistics(){ long startTime = System.currentTimeMillis(); Future processA = myAsyncService.processA(); Future processB = myAsyncService.processB(); try { Integer totalCount=processA.get()+processB.get(); System.out.println(\"totalCount is\"+totalCount); } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\"AsyncController-->statistics-->total time is\"+(endTime-startTime)); return \"success\"; } 3-test 所谓异步就是2个方法同时执行 上述异步方法是有返回值的，这样主流程在执行异步方法时会有短暂阻塞，需要等待并获取异步方法的返回结果，而调用的两个异步方法会作为两个子线程并行执行，直到异步方法执行完成并返回结果，这样主流程会在最后一个异步方法返回结果后跳出阻塞状态。 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/asynch-call.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 17:22:54 "},"task-management/timed-task.html":{"url":"task-management/timed-task.html","title":"定时任务","keywords":"","body":"定时任务介绍 https://www.jianshu.com/p/1defb0f22ed1 9.4 定时任务实现 新建一个定时任务管理的业务处理类ScheduledTaskService，并在该类中编写对应的定时任务处理方法。使用@Scheduled注解声明了三个定时任务方法，这三个方法定制的执行规则基本相同，都是每隔1分钟重复执行一次定时任务，在使用fixedDelay属性的方法scheduledTaskAfterSleep()中，使用Thread.sleep(10000)模拟该定时任务处理耗时为10秒钟。 service @Service public class ScheduledTaskService { private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); private Integer count1 = 1; private Integer count2 = 1; private Integer count3 = 1; //每隔1分钟，执行一次 @Scheduled(fixedRate = 60000) public void scheduledTaskImmediately() { System.out.println(String.format(\"fixedRate第%s次执行，当前时间为：%s\", count1++, dateFormat.format(new Date()))); } //每隔1分10秒（1分钟定时+业务处理时间10秒），执行一次 @Scheduled(fixedDelay = 60000) public void scheduledTaskAfterSleep() throws InterruptedException { System.out.println(String.format(\"fixedDelay第%s次执行，当前时间为：%s\", count2++, dateFormat.format(new Date()))); Thread.sleep(10000);//模拟业务处理时间 } //整秒输出 @Scheduled(cron = \"0 * * * * *\") public void scheduledTaskCron(){ System.out.println(String.format(\"cron第%s次执行，当前时间为：%s\", count3++, dateFormat.format(new Date()))); } } var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/timed-task.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 17:23:45 "},"task-management/send-email.html":{"url":"task-management/send-email.html","title":"发送邮件","keywords":"","body":"发送纯文本邮件 9.6 发送带附件和图片的文件 9.7 发送模板邮件 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/send-email.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 17:24:00 "},"integrated-project/integrated-project.html":{"url":"integrated-project/integrated-project.html","title":"综合项目","keywords":"","body":"Spring Boot综合项目实战 10.1系统概述 10.2系统开发及运行环境 10.3文件组织结构 10.4数据库设计 10.5系统环境搭建 10.6文章分页展示 10.7文章详情查看 10.8文章评论管理 10.9数据展示 10.10文章发布 10.11文章修改 10.12文章删除 10.13用户登录控制 10.14定时邮件发送 var targetUl = document.getElementsByClassName('page-inner')[0].getElementsByTagName('ul')[0];if(targetUl.getElementsByTagName('a').length>0){targetUl.className='toc';} 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/integrated-project/integrated-project.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 17:32:53 "}}
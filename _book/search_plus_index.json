{"./":{"url":"./","title":"首页 - Spring Boot 青铜篇","keywords":"","body":"自我介绍 金丝猴们， 该文档定位Spring Boot初学者， 主要帮助大家快速入门，故称为「青铜篇」。 开发环境 jdk 8.0 Spring Boot 2.x Maven 3.x JetBrain Idea 旗舰版 贡献 金丝猴们，点击「编辑本页」可以参与文档修改 欢迎大家指点修正 内容部分1； 内容部分2 [!NOTE] 这是一个简单的Note类型的使用，所有的属性都是默认值。 [!NOTE|style:flat|lable:Mylable|iconVisibility:hidden] \"!type\":NOTE、\"style\":flat、\"lable\":自定义标签、图标不可见 \"readmore\":{ \"blogId\": \"15702-1569305559839-744\", \"name\": \"雪之梦技术驿站\", \"qrcode\": \"https://snowdreams1006.github.io/snowdreams1006-wechat-public.jpeg\", \"keyword\": \"vip\" } 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/gitbook-plugin-readmore/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! 作者: 雪之梦技术驿站 链接: https://snowdreams1006.github.io/gitbook-plugin-readmore/ 来源: 雪之梦技术驿站 本文原创发布于「雪之梦技术驿站」,转载请注明出处,谢谢合作! 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/ 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-06 12:13:25 "},"introduction/introduction.html":{"url":"introduction/introduction.html","title":"开发入门","keywords":"","body":"Spring Boot 简介 Spring Boot 优点 快速构建项目 内嵌服务器（Tomcat,Jetty,Undertow），无需部署 war 包 依赖启动器简化构建配置 自动化配置 整合大量第三方库 Spring Boot 应用场景 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/introduction.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 18:29:19 "},"introduction/initialzr-build.html":{"url":"introduction/initialzr-build.html","title":"Spring Initialzr 构建项目","keywords":"","body":"悟空编号 sbqt001 配套视频 B 站链接： 使用Spring Initialzr方式构建 Spring Boot 项目 推荐：建议创建父子项目，而不是单体项目 推荐： 使用阿里 Maven 镜像构建项目，速度快 打开 maven 的配置文件 conf/settings.xml，在 标签中添加 mirror 子节点: aliyunmaven * 阿里云公共仓库 https://maven.aliyun.com/repository/public 创建父项目 创建子项目 第 1 步 第 2 步 第 3 步 检查目录结构是否完整 .mvn HELP.md mvnw mvnw.cmd 4 个文件（目录）可以直接删除 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/initialzr-build.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-04 10:38:57 "},"introduction/modify-banner.html":{"url":"introduction/modify-banner.html","title":"启动图标设置","keywords":"","body":"悟空编号 sbqt002 配套视频 B 站链接： introduction 修改启动图标 创建 /src/main/resources/banner.txt 文件 通过如下网站设置banner图标样式 http://patorjk.com/software/taag/#p=display&f=Graffiti&t=Type%20Something%20 or http://www.degraeve.com/img2txt.php 例如，如下图标复制到 banner.txt 文件中 __ __ .__ .__ __ _ ____ __ | | ______ ____ ____ ____ _____/ |_ ____ __ __| | | | \\ \\/ \\/ / | \\ | |/ / _ \\ / \\ / ___\\ / \\ / _ \\ __\\ / \\| | \\ | | | \\ /| | / | ) | \\/ /_/ > | | ( ) | | | \\ | / |_| |__ \\/\\_/ |____/ |__|_ \\____/|___| /\\___ / |___| /\\____/|__| |___| /____/|____/____/ \\/ \\//_____/ \\/ \\/ 关闭启动图标 banner图标如何关闭 @SpringBootApplication public class App { public static void main( String[] args ) { SpringApplication springApplication = new SpringApplication(App.class); // 关闭 banner 图标 springApplication.setBannerMode(Banner.Mode.OFF); springApplication.run(); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/modify-banner.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-05 10:54:48 "},"introduction/unit-test.html":{"url":"introduction/unit-test.html","title":"单元测试","keywords":"","body":"单元测试 pom org.springframework.boot spring-boot-starter-test test service 层单元测试 @SpringBootTest class MySpringbootApplicationTests { @Autowired private HelloController helloController; @Test public void contextLoads() { String hello = helloController.hello(); System.out.println(hello); } } controller层单元测试 视图层代码使用MockMvc 进行测试，这里以UserCntroller 为例,src/test/java 目录下添加测试包 com.wukong.controller 定义测试类代码如下: @RunWith(SpringRunner.class) @SpringBootTest(classes = {Starter.class}) @AutoConfigureMockMvc public class TestUserController { private Logger log = LoggerFactory.getLog ler.class); @Autowired private MockMvc mockMvc; //用户列表查询 @Test public void apiTest01()t MvcResult mvcResu ders.get(\"/user/list\")). andExp Ok()).andReturn(); log.info(\"响 Status()); log.info(\" getContentAsString());; } // 用户名记录查询 @Test public void apiTest02()t MvcResult mvcResult=mockMvc.perform(MockMvcR tBuilders.get(\"/user/uname/admin\")). andExpect(MockMvcResultMatchers.status().isOk()).andReturn(); log.info(\"响应状态:{}\",mvcResult.getResponse().getStatus()); log.info(\"响应内容:{}\",mvcResult.getResponse().getContentAsString());; } } @RunWith(SpringRunner.class) @SpringBootTest(classes = {Starter.class}) @AutoConfigureMockMvc public class TestUserController { private Logger log = LoggerFactory.getLog ler.class); @Autowired private MockMvc mockMvc; //用户列表查询 @Test public void apiTest01()t MvcResult mvcResu ders.get(\"/user/list\")). andExp Ok()).andReturn(); log.info(\"响 Status()); log.info(\" getContentAsString());; } // 用户名记录查询 @Test public void apiTest02()t MvcResult mvcResult=mockMvc.perform(MockMvcR tBuilders.get(\"/user/uname/admin\")). andExpect(MockMvcResultMatchers.status().isOk()).andReturn(); log.info(\"响应状态:{}\",mvcResult.getResponse().getStatus()); log.info(\"响应内容:{}\",mvcResult.getResponse().getContentAsString());; } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/unit-test.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 14:41:48 "},"introduction/hot-deploy.html":{"url":"introduction/hot-deploy.html","title":"热部署","keywords":"","body":"实操 pom文件钟添加spring-boot-devtools热部署依赖 org.springframework.boot spring-boot-devtools idea中热部署设置 第1步 第2步 ctrl+shift+alt(option)+/ 打开界面 热部署测试 使用浏览器测试，不需要重复启动main方法 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/hot-deploy.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:30:14 "},"introduction/dependency-management.html":{"url":"introduction/dependency-management.html","title":"依赖管理","keywords":"","body":"依赖管理 对依赖进行统一管理 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/dependency-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:31:11 "},"introduction/auto-config.html":{"url":"introduction/auto-config.html","title":"自动配置 ","keywords":"","body":"Spring Boot 自动配置 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/auto-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:35:44 "},"introduction/execute-flow.html":{"url":"introduction/execute-flow.html","title":"执行流程","keywords":"","body":"Spring Boot 执行流程 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/introduction/execute-flow.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 17:33:23 "},"config-annotation/config-annotation.html":{"url":"config-annotation/config-annotation.html","title":"核心配置与注解","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/config-annotation.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-10 18:49:20 "},"config-annotation/application-config.html":{"url":"config-annotation/application-config.html","title":"application 配置文件","keywords":"","body":"application.properties配置文件 配置端口号 #配置端口号 server.port=8090 #配置虚拟路径 server.servlet.context-path=/project-name application.yaml配置文件 #端口号 虚拟路径 server: port: 8091 servlet: context-path: /project-name2 注意 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/application-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 10:04:58 "},"config-annotation/inject-property.html":{"url":"config-annotation/inject-property.html","title":"属性注入","keywords":"","body":"@ConfigurationProperties注入属性 第1种方法 properties #给类属性赋值 person.id=1 person.name=wukongnotnull person.family=baba,mama,gege,jiejie person.hobbies=dance,game,110 person.map.level=3 person.map.salary=3000 person.pet.petName=wangcai person.pet.petAge=3 第二种方式yml #给类属性赋值 person: id: 2 name: wukongnotnull family: [baba,mama,gege,jiejie] hobbies: [dance,game,sing] map: {level: 3,salary: 3000} pet: {petName: wangcai, petAge: 3} 编写实体类 package com.wukongnotnull.domain; /* author: 悟空非空也（B站/知乎/公众号） */ public class Pet { private String petName; private int petAge; public String getPetName() { return petName; } public void setPetName(String petName) { this.petName = petName; } public int getPetAge() { return petAge; } public void setPetAge(int petAge) { this.petAge = petAge; } @Override public String toString() { return \"Pet{\" + \"petName='\" + petName + '\\'' + \", petAge=\" + petAge + '}'; } } 使用@Component,@ConfigurationProperties注解 package com.wukongnotnull.domain; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import java.util.Arrays; import java.util.List; import java.util.Map; @Component @ConfigurationProperties(prefix = \"person\") public class Person { private int id; private String name; private String[] family; private List hobbies; private Map map; private Pet pet; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public List getHobbies() { return hobbies; } public void setHobbies(List hobbies) { this.hobbies = hobbies; } public String[] getFamily() { return family; } public void setFamily(String[] family) { this.family = family; } public Map getMap() { return map; } public void setMap(Map map) { this.map = map; } public Pet getPet() { return pet; } public void setPet(Pet pet) { this.pet = pet; } @Override public String toString() { return \"Person{\" + \"id=\" + id + \", name='\" + name + '\\'' + \", family=\" + Arrays.toString(family) + \", hobbies=\" + hobbies + \", map=\" + map + \", pet=\" + pet + '}'; } } 测试类 @SpringBootTest class MySpringbootApplicationTests { @Autowired private Person person; @Test public void personTest(){ System.out.println(person); } } @Value注入属性 @Value直接注入属性 #给基本数据数据类型注入 flag=wukongnotnull 测试 @SpringBootTest class MySpringbootApplicationTests { @Value(value = \"${flag}\") //直接注入，不需要setter方法 private String flag; @Test public void showTest(){ System.out.println(\"姓名为--->\"+ flag); } @Value(value = \"${person.family[0]}\") private int familyName; @Test void valueTest(){ System.out.println(\"family--->\" + familyName); } } @ConfigurationProperties注解支持JSR303数据校验 person: id: 2 name: wukongnotnull family: [baba,mama,gege,jiejie] hobbies: [dance,game,110] map: {level: 3,salary: 3000} pet: {petName: wangcai, petAge: 3} application.properties #@ConfigurationProperties注解支持JSR303数据校验 user.email=1390128154@qq.com pom org.springframework.boot spring-boot-starter-validation 实体类 package com.wukongnotnullg.myspringboot.domain; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import org.springframework.validation.annotation.Validated; import javax.validation.constraints.Email; @Component @ConfigurationProperties(prefix = \"user\") @Validated public class User { @Email private String email; public String getEmail() { return email; } public void setEmail(String email) { this.email = email; } } test @Test public void validateTest(){ System.out.println(user.getEmail()); } 两种注解对比分析 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/inject-property.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-14 09:58:58 "},"config-annotation/custom-config.html":{"url":"config-annotation/custom-config.html","title":"自定义配置文件","keywords":"","body":"使用 @PropertySource 加载自定义配置文件 @PropertySource 源码 public @interface PropertySource { /** * Indicate the resource location(s) of the properties file to be loaded. * Both traditional and XML-based properties file formats are supported * &mdash; for example, {@code \"classpath:/com/myco/app.properties\"} * or {@code \"file:/path/to/file.xml\"}. * Resource location wildcards (e.g. *&#42;/*.properties) are not permitted; * each location must evaluate to exactly one {@code .properties} or {@code .xml} * resource. * ${...} placeholders will be resolved against any/all property sources already * registered with the {@code Environment}. See {@linkplain PropertySource above} * for examples. * Each location will be added to the enclosing {@code Environment} as its own * property source, and in the order declared. */ String[] value(); 案例 自定义配置文件 test.properties #自定义配置文件 test.id=1 test.name=wukongnotnull 实体类 package com.wukongnotnull.myspringboot.domain; import org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.boot.context.properties.EnableConfigurationProperties; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.PropertySource; import org.springframework.stereotype.Component; /** * @Author: 悟空非空也（公众号/B站/知乎） */ //注意：可以使用@Component代替 //@Configuration+@EnableConfigurationProperties(MyProperties.class) @Configuration//指定当前类为配置类 @EnableConfigurationProperties(MyProperties.class)//开启配置文件的属性注入功能 @PropertySource(value=\"classpath:test.properties\")//指定自定义配置文件的来源 @ConfigurationProperties(prefix = \"test\") public class MyProperties { private int id; private String name; public int getId() { return id; } public void setId(int id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } @Override public String toString() { return \"MyProperties{\" + \"id=\" + id + \", name='\" + name + '\\'' + '}'; } } 测试 @SpringBootTest class MySpringbootApplicationTests { @Autowired private MyProperties myProperties; @Test public void myPropertiesTest(){ System.out.println(\"myProperties===>\"+myProperties); } } 使用@ImportResource加载自定义的 spring xml 配置文件 @ImportResource 源码 public @interface ImportResource { /** * Resource locations from which to import. * Supports resource-loading prefixes such as {@code classpath:}, * {@code file:}, etc. * Consult the Javadoc for {@link #reader} for details on how resources * will be processed. * @since 4.2 * @see #value * @see #reader */ @AliasFor(\"value\") String[] locations() default {}; 案例 创建 spring xml 配置文件myBeans.xml 启动类上添加 @ImportResource 注解 package com.wukongnotnull; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.context.annotation.ImportResource; @SpringBootApplication @ImportResource(value = \"classpath:myBeans.xml\") public class InitializrProjectApplication { public static void main(String[] args) { SpringApplication.run(InitializrProjectApplication.class, args); } } test @SpringBootTest class InitializrProjectApplicationTests { @Autowired private ApplicationContext applicationContext; @Test void beansTest(){ Pet myPet =(Pet) applicationContext.getBean(\"myPet\"); System.out.println(\"myPet----->\" + myPet); } } 使用 @Configuration 编写自定义配置类 @Configuration 源码 @Target(ElementType.TYPE) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Configuration { /** * Explicitly specify the name of the Spring bean definition associated with the * {@code @Configuration} class. If left unspecified (the common case), a bean * name will be automatically generated. * The custom name applies only if the {@code @Configuration} class is picked * up via component scanning or supplied directly to an * {@link AnnotationConfigApplicationContext}. If the {@code @Configuration} class * is registered as a traditional XML bean definition, the name/id of the bean * element will take precedence. * @return the explicit component name, if any (or empty String otherwise) * @see AnnotationBeanNameGenerator */ @AliasFor(annotation = Component.class) String value() default \"\"; /** * Specify whether {@code @Bean} methods should get proxied in order to enforce * bean lifecycle behavior, e.g. to return shared singleton bean instances even * in case of direct {@code @Bean} method calls in user code. This feature * requires method interception, implemented through a runtime-generated CGLIB * subclass which comes with limitations such as the configuration class and * its methods not being allowed to declare {@code final}. * The default is {@code true}, allowing for 'inter-bean references' via direct * method calls within the configuration class as well as for external calls to * this configuration's {@code @Bean} methods, e.g. from another configuration class. * If this is not needed since each of this particular configuration's {@code @Bean} * methods is self-contained and designed as a plain factory method for container use, * switch this flag to {@code false} in order to avoid CGLIB subclass processing. * Turning off bean method interception effectively processes {@code @Bean} * methods individually like when declared on non-{@code @Configuration} classes, * a.k.a. \"@Bean Lite Mode\" (see {@link Bean @Bean's javadoc}). It is therefore * behaviorally equivalent to removing the {@code @Configuration} stereotype. * @since 5.2 */ boolean proxyBeanMethods() default true; } 案例 编写配置类 package com.wukongnotnull.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; /** * @Author: 悟空非空也（公众号/B站/知乎） */ @Configuration //定义该类为配置类 public class MyConfig { @Bean(name = \"aPet\") public MyService getMyService(){ return new Pet(); } } public class Pet { // properties } 测试 @Autowired private ApplicationContext applicationContext; @Test public void myServiceTest(){ Pet aPet = (Pet)applicationContext.getBean(\"aPet\"); System.out.println(aPet); } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/custom-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-14 15:07:08 "},"config-annotation/profile-config.html":{"url":"config-annotation/profile-config.html","title":"profile 文件配置","keywords":"","body":"使用profile文件进行多环境配置 多环境配置文件格式 方法一 使用命令行方式激活指定环境的配置文件 ctrl+c 服务器运行退出 ctrl+c 停止 方法二 在全局配置文件application.properties设置 spring.profiles.active属性激活 spring.profiles.active=test 案例 1 不同环境下使用不同端口 创建不同环境下配置文件 application.yml spring: profiles: active: test application-dev.yml server: port: 8081 application-prod.yml server: port: 8082 application-test.yml server: port: 8083 运行 main 方法，查看控制台的端口号输出信息 案例 2 不同环境下使用不同数据库 使用 @Profile 注解进行多环境配置 编写不同环境下的配置类 package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ public interface DBConnector { /** * 对不同的环境下的数据库设置统一接口约束 */ void configuration(); } package com.wukongnotnull.config;/* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; @Configuration @Profile(value = \"dev\") public class DevDBConnector implements DBConnector{ @Override public void configuration() { System.out.println(\"开发环境下连接数据库。。。\"); } } package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; @Configuration @Profile(value = \"pro\") public class ProDBConnector implements DBConnector{ @Override public void configuration() { System.out.println(\"生产环境下连接数据库。。。。。\"); } } package com.wukongnotnull.config;/* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Profile; @Configuration @Profile(value = \"test\") public class TestDBConnector implements DBConnector{ public void configuration() { System.out.println(\"测试环境下连接数据库。。。。\"); } } 在全局配置文件application.properties中指定使用哪个环境 spring.profiles.active=test #或者 #spring.profiles.active=pro #或者 #spring .profiles.active=dev 测试 @Autowired private DBConnector dbConnector; @Test public void dbConnectorTest(){ dbConnector.configuration(); } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/profile-config.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-14 16:36:19 "},"config-annotation/property-reference.html":{"url":"config-annotation/property-reference.html","title":"yml 高级玩法","keywords":"","body":"参数间引用 application.properties # 参数间的引用 app.name=wukongnotnull app.description=${app.name} is a technology blog website, welcome your comming. wukong.age=${random.int[10,20]} wukong.description=悟空非空也的年龄可能是 ${wukong.age} test @SpringBootTest class MySpringbootApplicationTests { @Value(\"${wukong.description}\") private String authorDes; @Test void contextLoads() { System.out.println(authorDes); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/config-annotation/property-reference.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-14 16:52:15 "},"data-access/data-access.html":{"url":"data-access/data-access.html","title":"数据访问","keywords":"","body":"Spring Boot 数据访问概述 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/data-access.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-14 17:19:07 "},"data-access/env-setup.html":{"url":"data-access/env-setup.html","title":"环境搭建","keywords":"","body":"基础环境搭建 创建数据库 CREATE DATABASE wukong_blog; USE wukong_blog; CREATE TABLE `b_article` ( `id` INT(20) NOT NULL AUTO_INCREMENT COMMENT '文章id', `title` VARCHAR(200) DEFAULT NULL COMMENT '文章标题', `content` LONGTEXT COMMENT '文章内容', PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `b_article` VALUES ('1', 'Spring Boot 青铜篇', '从入门到放弃讲解...'); INSERT INTO `b_article` VALUES ('2', 'Spring Cloud 王者篇', '从入门到入土讲解...'); CREATE TABLE `b_comment` ( `id` INT(20) NOT NULL AUTO_INCREMENT COMMENT '评论id', `content` LONGTEXT COMMENT '评论内容', `author` VARCHAR(200) DEFAULT NULL COMMENT '评论作者', `article_id` INT(20) DEFAULT NULL COMMENT '外键：文章id', PRIMARY KEY (`id`) ) ENGINE=INNODB DEFAULT CHARSET=utf8; INSERT INTO `b_comment` VALUES ('1', '赞1', 'wukong', '1'); INSERT INTO `b_comment` VALUES ('2', '赞2', 'zhubajie', '1'); INSERT INTO `b_comment` VALUES ('3', '赞3', 'tangseng', '1'); INSERT INTO `b_comment` VALUES ('4', '赞4', 'bailongma', '2'); INSERT INTO `b_comment` VALUES ('5', '赞5', 'baigujing', '2'); 创建项目,引入mysql和mybatis的依赖启动器 创建实体类domain 推荐实体类使用 lombok 插件，编译后自动生成 setter | getter 方法。 package com.wukongnotnull.domain; /* author: 悟空非空也（B站/知乎/公众号） */ import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; @Data @NoArgsConstructor @AllArgsConstructor public class Article { private Integer id; private String title; private String content; } package com.wukongnotnull.domain; /* author: 悟空非空也（B站/知乎/公众号） */ import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import lombok.ToString; @Data @NoArgsConstructor @AllArgsConstructor public class Comment { private Integer id; private String content; private String author; //此属性名和表中的字段article_id不一致，不能自动映射，需要在application.yml中进行配置 //mybatis.configuration.map-underscore-to-camel-case=true private Integer articleId; } 全局配置文件进行数据库连接配置 application.properties spring: datasource: url: jdbc:mysql://localhost:3306/wukong_blog?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&autoReconnect=true driver-class-name: com.mysql.cj.jdbc.Driver username: root password: rootroot 使用第三方数据源进行配置（推荐：ali的druid数据源为例） pom.xml com.alibaba druid-spring-boot-starter 1.1.22 在全局配置文件中设置druid的属性 application.yml spring: datasource: type: com.alibaba.druid.pool.DruidDataSource initialSize: 30 minIdle: 20 maxActive: 200 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/env-setup.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-16 10:43:53 "},"data-access/integrate-mybatis.html":{"url":"data-access/integrate-mybatis.html","title":"整合 MyBatis","keywords":"","body":"使用注解的方式整合MyBatis mapper接口 package com.wukongnotnull.mapper; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import org.apache.ibatis.annotations.*; @Mapper public interface CommentMapper { // 查询 @Select(\"select * from b_comment where id = #{id}\") public Comment queryComment(Integer id); //删除 @Delete(\"delete from b_comment where id=#{id}\") public int deleteComment(@Param(\"id\") Integer id); // 修改 @Update(\"update b_comment set content = #{content}, author = #{author} where id = #{id}\") public int updateComment(Comment comment); // 添加，注意是 #{articleId} ，不是#{article_id} @Insert(\"insert into b_comment(content,author,article_id) values(#{content},#{author},#{articleId})\") public int insertComment(Comment comment); } 测试 package com.wukongnotnull.mapper; import com.wukongnotnull.domain.Comment; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; /* author: 悟空非空也（B站/知乎/公众号） */ @SpringBootTest class CommentMapperTest { @Autowired private CommentMapper commentMapper; @Test void queryComment() { System.out.println(commentMapper.queryComment(2)); } @Test void deleteComment() { System.out.println(commentMapper); System.out.println(commentMapper.deleteComment(5)); } @Test void updateComment(){ Comment comment = new Comment(); comment.setId(2); comment.setContent(\"11111\"); comment.setAuthor(\"111\"); System.out.println(commentMapper.updateComment(comment)); } @Test void insertComment(){ Comment comment = new Comment(); comment.setContent(\"add11111\"); comment.setAuthor(\"add11111\"); comment.setArticleId(1); System.out.println(commentMapper.insertComment(comment)); } } 使用配置文件的方式整合MyBatis 在全局配置文件配置 mapper-locations: classpath:mapper/** 该位置是在 resources 文件夹下新建 mapper 目录 mybatis: configuration: map-underscore-to-camel-case: true mapper-locations: classpath:mapper/** type-aliases-package: com.wukongnotnull.domain 编写ArticleMapper接口 package com.wukongnotnull.mapper; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Article; import org.apache.ibatis.annotations.Mapper; import org.springframework.stereotype.Component; import java.util.List; // 不要忘记 @Mapper @Mapper public interface ArticleMapper { // 查询单文章 Article getArticleById(int id); // 查询文章列表 List getArticleList(); // 修改文章 int updateArticle(Article article); // 添加文章 int addArticle(Article article); // 删除文章 int delArticle(int id); } 编写接口对应的xml配置文件 select * from b_article where id = #{id} select * from b_article update b_article set title = #{title}, content = #{content} where id = #{id} insert into b_article(title,content) values(#{title},#{content}) delete from b_article where id = #{id} 测试 package com.wukongnotnull.mapper; import com.wukongnotnull.domain.Article; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import static org.junit.jupiter.api.Assertions.*; /* author: 悟空非空也（B站/知乎/公众号） */ @SpringBootTest class ArticleMapperTest { @Autowired private ArticleMapper articleMapper; @Test void delArticle(){ System.out.println(articleMapper.delArticle(3)); } @Test void addArticle(){ Article article = new Article(); article.setTitle(\"add 1029\"); article.setContent(\"add content 1030\"); System.out.println(articleMapper.addArticle(article)); } @Test void updateArticle(){ Article article = new Article(); article.setId(2); article.setTitle(\"update 1026...\"); article.setContent(\"content 1026\"); System.out.println(articleMapper.updateArticle(article)); } @Test void getArticleList(){ System.out.println(articleMapper.getArticleList()); } @Test void getArticleById() { System.out.println(articleMapper.getArticleById(1)); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/integrate-mybatis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 10:28:46 "},"data-access/integrate-jpa.html":{"url":"data-access/integrate-jpa.html","title":"整合 JPA","keywords":"","body":"Spring Date JPA介绍 Spring Data 是Spring的一个子项目，旨在统一和简化各类型数据的持久化存储方式，而不拘泥于是关系型数据库还是NoSQL数据库。无论是哪种持久化存储方式，数据访问对象（Data Access Objects，DAO）都会提供对对象的增加、删除、修改和查询的方法，以及排序和分页方法等。 Spring Data 提供了基于这些层面的统一接口（如：CrudRepository、 PagingAndSortingRepository），以实现持久化的存储。 JPA（Java Persistence API）是Java的持久化API，用于对象的持久化。它是一个非常强大的ORM持久化的解决方案，免去了使用JDBCTemplate开发的编写脚本工作。JPA通过简单约定好接口方法的规则自动生成相应的JPQL语句，然后映射成POJO对象。 JPA是一个规范化接口，封装了Hibernate的操作作为默认实现，让用户不通过任何配置即可完成数据库的操作。 使用Spring Boot整合JPA pom org.springframework.boot spring-boot-starter-data-jpa 实体类和表进行映射 package com.wukongnotnull.domain;/* author: 悟空非空也（B站/知乎/公众号） */ import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @NoArgsConstructor @AllArgsConstructor @Entity(name = \"b_comment\") public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"content\" ) private String content; @Column(name = \"author\") private String author; //此属性名和表中的字段article_id不一致，不能自动映射，需要在application.yml中进行配置 //mybatis.configuration.map-underscore-to-camel-case=true @Column(name = \"article_id\") private Integer articleId; } 自定义dao层的操作数据库的接口 默认继承父接口，父接口提供了简单的增删改查方法，但是还不能满足业务需求，那就需要自定义方法吧 package com.wukongnotnull.repository; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import javax.transaction.Transactional; import java.util.List; import java.util.Optional; public interface CommentRepository extends JpaRepository { @Override List findAll(); @Override Optional findById(Integer id); // 查询条件：作者不为空 List findByAuthorNotNull(); @Override long count(); @Override S saveAndFlush(S s); @Query(\"select c from b_comment c where c.articleId=?1\") List getCommentList(Integer articleId); @Query(value = \"select * from b_comment c where c.article_id=?1\",nativeQuery = true) List getCommentList2(Integer articleId); @Transactional @Modifying @Query(value = \"update b_comment set author =?1 where id =?2 \",nativeQuery = true) int updateComment(String author,Integer id); @Transactional @Modifying @Query(value = \"delete from b_comment where id = ?1\",nativeQuery = true) int deleteComment(Integer id); @Override S save(S entity); } 测试一下吧 package com.wukongnotnull.repository; import com.wukongnotnull.domain.Comment; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; /* author: 悟空非空也（B站/知乎/公众号） */ @SpringBootTest class CommentRepositoryTest { @Autowired private CommentRepository commentRepository; @Test void findAll() { System.out.println(commentRepository.findAll()); } @Test void findById() { System.out.println(commentRepository.findById(1)); } @Test void findByAuthorNotNull(){ System.out.println(commentRepository.findByAuthorNotNull()); } @Test void count(){ System.out.println(commentRepository.count()); } @Test void getCommentList(){ System.out.println(commentRepository.getCommentList(1)); } @Test void getCommentList2(){ System.out.println(commentRepository.getCommentList2(1)); } @Test void updateComment(){ System.out.println(commentRepository.updateComment(\"6666\", 6)); } @Test void deleteComment(){ System.out.println(commentRepository.deleteComment(6)); } @Test void save(){ Comment comment = new Comment(); comment.setAuthor(\"wukongnotnull0716\"); comment.setContent(\"content .... wukong ...\"); System.out.println(commentRepository.save(comment)); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/integrate-jpa.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-16 15:14:31 "},"data-access/integrate-redis.html":{"url":"data-access/integrate-redis.html","title":"整合 Redis","keywords":"","body":"Redis介绍 什么是Redis Redis 是一个开源（BSD许可）的、内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件，并提供多种语言的API。 优点 1.存取速度快：Redis速度非常快，每秒可执行大约110000次的设值操作，或者执行81000次的读取操作。 2.支持丰富的数据类型：Redis支持开发人员常用的大多数数据类型，例如列表、集合、排序集和散列等。 3.操作具有原子性：所有Redis操作都是原子操作，这确保如果两个客户端并发访问，Redis服务器能接收更新后的值。 4.提供多种功能：Redis提供了多种功能特性，可用作非关系型数据库、缓存中间件、消息中间件等。 Redis下载与安装 下载路径 https://github.com/microsoftarchive/redis/releases/tag/win-3.2.100 解压后放入磁盘某位置就安装成功（免安装） 安装可视化客户端 使用Spring Boot整合Redis 1.在pom文件中添加Spring Data Redis依赖启动器 org.springframework.boot spring-boot-starter-data-redis 2.在全局配置文件application.properties中添加Redis数据库连接配置 spring: redis: host: 127.0.0.1 port: 6379 password: 3.编写实体类 package com.wukongnotnull.domain;/* author: 悟空非空也（B站/知乎/公众号） */ import lombok.Data; import org.springframework.data.annotation.Id; import org.springframework.data.redis.core.RedisHash; import org.springframework.data.redis.core.index.Indexed; import java.util.List; @Data @RedisHash(value = \"people\") public class Person { @Id private String id; @Indexed private String firstName; @Indexed private String lastName; private Address address; private List familyList; } package com.wukongnotnull.domain;/* author: 悟空非空也（B站/知乎/公众号） */ import lombok.Data; import org.springframework.data.redis.core.index.Indexed; @Data public class Address { @Indexed private String nation; @Indexed private String village; } package com.wukongnotnull.domain;/* author: 悟空非空也（B站/知乎/公众号） */ import lombok.Data; import org.springframework.data.redis.core.index.Indexed; @Data public class Family { @Indexed private String type; @Indexed private String name; } 4.编写Repository接口 package com.wukongnotnull.repository;/* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Person; import org.springframework.data.repository.CrudRepository; public interface PersonRepository extends CrudRepository { Person findPersonByFirstName(String firstName); @Override S save(S entity); } 5.编写单元测试进行接口方法测试以及整合测试 package com.wukongnotnull.repository; import com.wukongnotnull.domain.Address; import com.wukongnotnull.domain.Family; import com.wukongnotnull.domain.Person; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import java.util.ArrayList; import java.util.List; /* author: 悟空非空也（B站/知乎/公众号） */ @SpringBootTest class PersonRepositoryTest { @Autowired private PersonRepository personRepository; @Test void findPersonByFirstName() { System.out.println(personRepository.findPersonByFirstName(\"空\")); } @Test void save() { Person person = new Person(); person.setId(\"002\"); person.setLastName(\"悟\"); person.setFirstName(\"空\"); Address address = new Address(); address.setNation(\"中国\"); address.setVillage(\"南京\"); person.setAddress(address); List familyList = new ArrayList<>(); Family father = new Family(); father.setType(\"father\"); father.setName(\"杨康\"); Family mother = new Family(); mother.setType(\"mother\"); mother.setName(\"穆念慈\"); familyList.add(father); familyList.add(mother); person.setFamilyList(familyList); System.out.println(personRepository.save(person)); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/data-access/integrate-redis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-16 17:44:12 "},"log-management/log-management.html":{"url":"log-management/log-management.html","title":"日志管理","keywords":"","body":"日志 ​ 开启日志 debug: true #开启日志 logging: level: com.sangeng: debug #设置日志级别 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/log-management/log-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-05 23:29:19 "},"log-management/default-log.html":{"url":"log-management/default-log.html","title":"默认日志管理","keywords":"","body":"默认日志框架 logback  java web 下有好几种日志框架，比如：logback，log4j，log4j2（slj4f 并不是一种日志框架，它相当于定义了规范，实现了这个规范的日志框架就能够用 slj4f 调用）。其中性能最高的应该使 logback 了，而且 springboot 默认使用的也是 logback 日志。默认情况下 Spring Boot 将 info 级别的日志输出到控制台中，不会写到日志文件，且不能进行复杂配置。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; Logger logger = LoggerFactory.getLogger(App.class); logger.info(\"我是 springboot的默认日志系统.....\"); 日志的复杂配置 写到日志文件中。如果要编写除控制台输出之外的日志文件，则需要application.yml中设置logging.file 或者logging.path属性。 logging: file: # 项目路径下的log目录下的spring.log 文件（默认名为 spring.log） path: ./log # 自定义日志名，存放在项目路径下 （name 优先级高于 path） name: ./resources.log 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/log-management/default-log.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-05 13:33:55 "},"aop-intergrate/aop-intergrate.html":{"url":"aop-intergrate/aop-intergrate.html","title":"整合 Aop","keywords":"","body":"AOP ​ 在SpringBoot中默认是开启AOP功能的 spring: aop: auto: true 4.11.1 使用步骤 ①添加依赖 org.springframework.boot spring-boot-starter-aop ②自定义注解 @Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) public @interface InvokeLog { } ③定义切面类 @Aspect //标识这是一个切面类 @Component public class InvokeLogAspect { //确定切点 @Pointcut(\"@annotation(com.sangeng.aop.InvokeLog)\") public void pt(){ } @Around(\"pt()\") public Object printInvokeLog(ProceedingJoinPoint joinPoint){ //目标方法调用前 Object proceed = null; MethodSignature signature = (MethodSignature) joinPoint.getSignature(); String methodName = signature.getMethod().getName(); System.out.println(methodName+\"即将被调用\"); try { proceed = joinPoint.proceed(); //目标方法调用后 System.out.println(methodName+\"被调用完了\"); } catch (Throwable throwable) { throwable.printStackTrace(); //目标方法出现异常了 System.out.println(methodName+\"出现了异常\"); } return proceed; } } ④在需要正确的地方增加对应的注解 @Service public class UserServiceImpl implements UserServcie { @Autowired private UserMapper userMapper; @Override @InvokeLog //需要被增强方法需要加上对应的注解 public List findAll() { return userMapper.findAll(); } } 4.11.2 切换动态代理 ​ 有的时候我们需要修改AOP的代理方式。 ​ 我们可以使用以下方式修改： ​ 在配置文件中配置spring.aop.proxy-target-class为false这为使用jdk动态代理。该配置默认值为true，代表使用cglib动态代理。 @SpringBootApplication @EnableAspectJAutoProxy(proxyTargetClass = false)//修改代理方式 public class WebApplication { public static void main(String[] args) { ConfigurableApplicationContext context = SpringApplication.run(WebApplication.class, args); } } ​ 如果想生效还需要在配置文件中做如下配置 spring: aop: proxy-target-class: false #切换动态代理的方式 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/aop-intergrate/aop-intergrate.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-05 23:27:46 "},"transaction-management/transaction-management.html":{"url":"transaction-management/transaction-management.html","title":"事务管理","keywords":"","body":"事务管理 Spring Boot 集成了Mybatis框架，Mybatis底层数据访问层实现基于jdbc 来实现，所以在Spring Boot 环境下对 事物进行控制，事务实现由Spring Boot实现并自动配置，在使用时通过注解方式标注相关方法加入事务控制即可 @Service public class UserServiceImpl implements UserService { @Resource private UserMapper userMapper; //增删改上添加 该注解即可 （查询不需要） @Transactional(propagation = Propagation.REQUIRED) public void addUser(User user) { ...... ...... } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/transaction-management/transaction-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 11:20:00 "},"view-tech/view-tech.html":{"url":"view-tech/view-tech.html","title":"支持视图技术","keywords":"","body":"Spring Boot 支持的视图技术 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/view-tech/view-tech.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-17 17:59:41 "},"view-tech/static-resource.html":{"url":"view-tech/static-resource.html","title":"访问静态资源","keywords":"","body":"访问静态资源 由于SpringBoot的项目一般打成jar包，项目结构中没有 webapps 目录。 那么，静态资源要放到哪里呢？ 从SpringBoot官方文档中我们可以知道，我们可以把静态资源放到 resources/static (或者 resources/public 或者resources/resources 或者 resources/META-INF/resources) 中即可。 那么，静态资源如何访问呢？ 访问文件：resources/static/index.html 只需要在访问时资源路径写成 /index.html 即可 。 访问文件：resources/static/pages/login.html 访问的资源路径写成 /pages/login.html 。 修改访问路径 SpringBoot 默认静态资源的路径匹配为/** 。若要修改请设置 spring.mvc.static-path-pattern 。 在application.yml中 spring: mvc: static-path-pattern: /wk/** #修改静态资源访问路径 修改存放目录 根据 spring.web.resources.static-locations 自定义静态资源存放位置。 可以存放在 src/main/resources/static/ 或者 src/main/resources/public/ 或者 src/main/resources/wukong/ spring: web: resources: static-locations: classpath:/static/,classpath:/public/,classpath:/resources/ css 和 js , 同理 http://localhost:8080/wukong/mycss.css http://localhost:8080/wukong/myjs.js 也可以分别被引入到html页面中 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/view-tech/static-resource.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-05 13:33:55 "},"view-tech/thymeleaf.html":{"url":"view-tech/thymeleaf.html","title":"整合 thymeleaf","keywords":"","body":"Thymeleaf 介绍 Thymeleaf 官网https://www.thymeleaf.org/index.html Thymeleaf is a modern server-side Java template engine for both web and standalone environments. Thymeleaf's main goal is to bring elegant natural templates to your development workflow — HTML that can be correctly displayed in browsers and also work as static prototypes, allowing for stronger collaboration in development teams. With modules for Spring Framework, a host of integrations with your favourite tools, and the ability to plug in your own functionality, Thymeleaf is ideal for modern-day HTML5 JVM web development — although there is much more it can do. Natural templates HTML templates written in Thymeleaf still look and work like HTML, letting the actual templates that are run in your application keep working as useful design artifacts. Name Price Oranges 0.99 官网教学文档https://www.thymeleaf.org/documentation.html Thymeleaf 常用标签 Thymeleaf 标准表达式 整合 Thymeleaf 创建springboot项目 org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 配置thymeleaf模板缓存application.yml spring: thymeleaf: mode: HTML prefix: classpath:/templates/ suffix: .html cache: false encoding: UTF-8 使用 Thymeleaf 完成数据的页面展示 #模板缓存改成false，上线后改成true spring: cache: false 使用Thymeleaf配置国际化页面 前端资源目录结构 前端资源下载链接 https://share.weiyun.com/iVq52myH login.html 用户登录界面 请登录 [[#{login.rememberme}]] 登录 © 2018-2019 中文 English login.properties login.tip=请登录 login.username=用户名 login.password=密码 login.rememberme=记住我 login.button=登录 login_zh_CN.properties login.tip=请登录 login.username=用户名 login.password=密码 login.rememberme=记住我 login.button=登录 login_en_US.properties login.tip=Please sign in login.username=Username login.password=Password login.rememberme=Remember me login.button=Login 在application.properties中配置国际化文件的基础名 #配置国际化文件基础名 spring.messages.basename=i18n.login 定制区域化解析器 在 com.wukongnotnull.config 下创建 MyLocaleResolver 类 package com.wukongnotnull.config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.lang.Nullable; import org.springframework.util.StringUtils; import org.springframework.web.servlet.LocaleResolver; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.util.Locale; @Configuration public class MyLocaleResolver implements LocaleResolver { // 自定义区域解析方式 @Override public Locale resolveLocale(HttpServletRequest httpServletRequest) { // 获取页面手动切换传递的语言参数l String l = httpServletRequest.getParameter(\"l\"); // 获取请求头自动传递的语言参数Accept-Language String header = httpServletRequest.getHeader(\"Accept-Language\"); Locale locale=null; // 如果手动切换参数不为空，就根据手动参数进行语言切换，否则默认根据请求头信息切换 if(!StringUtils.isEmpty(l)){ String[] split = l.split(\"_\"); locale=new Locale(split[0],split[1]); }else { // Accept-Language: en-US,en;q=0.9,zh-CN;q=0.8,zh;q=0.7 String[] splits = header.split(\",\"); String[] split = splits[0].split(\"-\"); locale=new Locale(split[0],split[1]); } return locale; } @Override public void setLocale(HttpServletRequest httpServletRequest, @Nullable HttpServletResponse httpServletResponse, @Nullable Locale locale) { } // 将自定义的MyLocaleResolver类重新注册为一个类型LocaleResolver的Bean组件 @Bean public LocaleResolver localeResolver(){ return new MyLocaleResolver(); } } controller package com.wukongnotnull.controller; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import java.util.Calendar; @Controller public class IndexController { @GetMapping(value = \"/login\") public String login(){ return \"login\"; } @GetMapping(value = \"/toLoginPage\") public String toLoginPage(Model model){ int currentYear = Calendar.getInstance().get(Calendar.YEAR); model.addAttribute(\"currentYear\",currentYear); return \"login\"; } } 启动后浏览器测试 中文乱码解决 原因 解决方案 最佳方案 在创建新项目前，将idea进行字符编码设置，这样保证项目和配置文件中的所有中文打字都是使用utf-8编码 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/view-tech/thymeleaf.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-19 09:34:29 "},"view-tech/freemarker.html":{"url":"view-tech/freemarker.html","title":"整合 freemarker","keywords":"","body":"集成freemarker视图 SpringBoot内部支持Freemarker 视图技术的集成，并提供了自动化配置类FreeMarkerAutoConﬁguration，借助自 动化配置可以很方便的集成Freemarker 视图到SpringBoot环境中。 pom org.springframework.boot spring-boot-starter-freemarker 修改 Freemarker 配置信息 Freemarker 默认视图路径为 resources/templates 目录(由自动化配置类FreemarkerProperties 类决定)， 该目录可以在application.yml 中进行修改。 spring: freemarker: charset: utf-8 content-type: text/html # 默认是 resources/templates ,改成 resources/views template-loader-path: classpath:/views/ suffix: .ftl controller @RequestMapping(\"/hello\") public String showHello(){ return \"hello\"; } resources/views/hello.ftl hello ,悟空非空也，我是freemarker模板 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/view-tech/freemarker.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 10:16:08 "},"web-dev/web-dev.html":{"url":"web-dev/web-dev.html","title":"实现 Web 开发","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/web-dev.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 08:55:14 "},"web-dev/integrate-mvc.html":{"url":"web-dev/integrate-mvc.html","title":"整合 MVC 和拦截器","keywords":"","body":"整合 Spring MVC pom org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 编写自定义配置类并实现WebMvcConfigurer package com.wukongnotnull.config; import com.wukongnotnull.interceptor.MyInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/toLoginPage\").setViewName(\"login\"); registry.addViewController(\"/login.html\").setViewName(\"login\"); } } login 页面展示 登录页面 用户名： 密码： 自定义拦截器组件 拦截器实现未登录下，没有访问主页的权限 package com.wukongnotnull.interceptor; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Component; import org.springframework.web.servlet.HandlerInterceptor; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; @Component public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { Object username = request.getSession().getAttribute(\"userSession\"); if (username == null) { response.sendRedirect(request.getContextPath()+\"/login\"); // 拦截 return false; } // 放行 return true; } } 在 MyMvcConfig 配置类中添加拦截器的相关配置 package com.wukongnotnull.config; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.interceptor.MyInterceptor; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.InterceptorRegistry; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurer; @Configuration public class MyMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\"/login\").setViewName(\"login\"); registry.addViewController(\"/toLoginPage\").setViewName(\"login\"); } @Autowired private MyInterceptor myInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { // 拦截所有请求，除了 /login 和 /doLogin registry.addInterceptor(myInterceptor).addPathPatterns(\"/**\") .excludePathPatterns(\"/login\") .excludePathPatterns(\"/doLogin\"); } } 测试 localhost:8080/home localhost:8080/login 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/integrate-mvc.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-19 15:16:42 "},"web-dev/mvc-validation.html":{"url":"web-dev/mvc-validation.html","title":"数据校验 Validation","keywords":"","body":"springMVC 数据校验 validation 日常项目开发中，对于前端提交的表单，后台接口接收到表单数据后，为了程序的严谨性，通常后端会加入业务参数 的合法校验操作来避免程序的非技术性bug，这里对于客户端提交的数据校验，SpringBoot通过spring-boot-starter-validation 模块包含了数据校验的工作。 相关概念如下 JSR303/JSR-349: JSR303是一项标准,只提供规范不提供实现，规定一些校验规范即校验注解，如@Null， @NotNull，@Pattern，位于javax.validation.constraints包下。JSR-349是其升级版本，添加了一些新特性。 Hibernate Validation： Hibernate Validation是对这个规范的实现，并增加了一些其他校验注解，如@Email， @Length，@Range等等 。 Spring Validation：Spring Validation对Hibernate Validation进行了二次封装，在Spring Mvc模块中添加了自 动校验，并将校验信息封装进了特定的类 pom 实现参数校验，程序必须引入spring-boot-starter-validation 依赖. 在版本2.2.2中，引入spring-boot-starter-web依赖时，自动引入依赖spring-boot-starter-validation。 因为 spring-boot-starter-web 依赖中包含 spring-boot-starter-validation。 其他版本不一定噢 ，要自己检查一下哈。 org.springframework.boot spring-boot-starter-validation user 实体类 import org.hibernate.validator.constraints.Length; import javax.validation.constraints.NotBlank; public class User implements Serializable { private Integer id; @NotBlank(message =\"用户名不能为空哈\") private String username; @Length(min =1 ,max = 10,message = \"密码长度为1~10之间哈\") @NotBlank(message = \"用户密码不能为空!\") private String password; controller import org.springframework.validation.annotation.Validated; public Object addUser02(@Validated User user){ ResultInfo resultInfo = new ResultInfo(); this.userService.addUser(user); return resultInfo; } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/mvc-validation.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 13:59:20 "},"web-dev/global-exception.html":{"url":"web-dev/global-exception.html","title":"全局异常处理","keywords":"","body":"全局异常处理 在Spring Boot 提供了对异常的全局性处理，相关注解如下: @ControllerAdvice 该注解组合了@Component注解功能,最常用的就是作为全局异常处理的切面类,同时通过该注解可以指定包扫描的范 围。@ControllerAdvice约定了几种可行的返回值，如果是直接返回model类的话，需要使用@ResponseBody进行 json转换 @ExceptionHandler 该注解在Spring 3.X 版本引入，在处理异常时标注在方法级别，代表当前方法处理的异常类型有哪些 以 Restful 接口为例,测试保存用户接口 package com.wukong.exception; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukong.utils.ParamsException; import com.wukong.vo.ResultInfo; import org.springframework.web.bind.annotation.ControllerAdvice; import org.springframework.web.bind.annotation.ExceptionHandler; import org.springframework.web.bind.annotation.ResponseBody; @ControllerAdvice public class GlobalExceptionHandler { @ExceptionHandler(value = {Exception.class}) @ResponseBody public ResultInfo handleException(Exception e){ ResultInfo resultInfo = new ResultInfo(); resultInfo.setCode(300); resultInfo.setMsg(\"系统异常\"); if(e instanceof ParamsException){ ParamsException paramsException = (ParamsException) e; resultInfo.setCode(paramsException.getCode()); resultInfo.setMsg(paramsException.getMsg()); } return resultInfo; } } 或者 @ExceptionHandler(value = {ParamsException.class}) @ResponseBody public ResultInfo handleParamsException(ParamsException paramsException){ ResultInfo resultInfo = new ResultInfo(); resultInfo.setCode(paramsException.getCode()); resultInfo.setMsg(paramsException.getMsg()); return resultInfo; } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/global-exception.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 13:58:29 "},"web-dev/integrate-servlet.html":{"url":"web-dev/integrate-servlet.html","title":"整合 Servlet Filter Listener","keywords":"","body":"组件注册方式整合Servlet三大组件 3 大组件分别是 servlet filter 和 listener 整合 servlet 组件 servlet 负责和浏览器进行交互 ，接受请求，找到相对应的响应信息，返回给客户端（浏览器） myServlet package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.stereotype.Component; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @Component public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\"hello MyServlet ,hello wukong\"); } } servletConfig package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.servlet.MyServlet; import org.springframework.boot.web.servlet.ServletRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class ServletConfig { // 注册Servlet组件 @Bean public ServletRegistrationBean getServlet(MyServlet myServlet){ return new ServletRegistrationBean<>(myServlet,\"/myServlet\"); } } 测试 通过路径找到对应的资源文件，返回给浏览器。 filter 自定义 MyFilter package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.stereotype.Component; import javax.servlet.*; import java.io.IOException; @Component public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"悟空非空也在执行过滤操作。。。。\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } FilterConfig package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.servlet.MyFilter; import org.springframework.boot.web.servlet.FilterRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.Arrays; import java.util.Collections; @Configuration public class FilterConfig { // 注册filter组件 @Bean public FilterRegistrationBean getFilter(MyFilter myFilter){ FilterRegistrationBean myFilterFilterRegistrationBean = new FilterRegistrationBean<>(myFilter); myFilterFilterRegistrationBean.setUrlPatterns(Arrays.asList(\"/myServlet\")); return myFilterFilterRegistrationBean; } } listener MyListener package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.stereotype.Component; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; @Component public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"ServletContextListener 开始初始化.....\"); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"ServletContextListener 销毁掉.....\"); } } listenerConfig package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.servlet.MyListener; import org.springframework.boot.web.servlet.ServletListenerRegistrationBean; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; @Configuration public class ListenerConfig { @Bean public ServletListenerRegistrationBean getListener(MyListener myListener){ return new ServletListenerRegistrationBean<>(myListener); } } 路径扫描方式整合Servlet三大组件 启动类 添加注解 @ServletComponentScan @SpringBootApplication @ServletComponentScan public class WebappThymeleafApplication { public static void main(String[] args) { SpringApplication.run(WebappThymeleafApplication.class, args); } } myServlet 添加注解 @WebServlet(value = {\"/myServlet\"}) package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.stereotype.Component; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; @WebServlet(value = {\"/myServlet\"}) public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { this.doPost(req, resp); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { resp.getWriter().write(\"hello MyServlet ,hello wukong\"); } } myFilter 添加注解 @WebFilter(value = {\"/myServlet\"}) package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import javax.servlet.*; import javax.servlet.annotation.WebFilter; import java.io.IOException; @WebFilter(value = {\"/myServlet\"}) public class MyFilter implements Filter { @Override public void init(FilterConfig filterConfig) throws ServletException { } @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"悟空非空也在执行过滤操作。。。。\"); filterChain.doFilter(servletRequest,servletResponse); } @Override public void destroy() { } } myListener.java 添加注解 @WebListener package com.wukongnotnull.servlet; /* author: 悟空非空也（B站/知乎/公众号） */ import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.servlet.annotation.WebListener; @WebListener public class MyListener implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent sce) { System.out.println(\"ServletContextListener 开始初始化.....\"); } @Override public void contextDestroyed(ServletContextEvent sce) { System.out.println(\"ServletContextListener 销毁掉.....\"); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/integrate-servlet.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-19 14:58:01 "},"web-dev/file-upload.html":{"url":"web-dev/file-upload.html","title":"文件上传","keywords":"","body":"多文件上传 controller package com.wukongnotnull.controller; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.multipart.MultipartFile; import javax.servlet.http.HttpServletRequest; import java.io.File; import java.io.IOException; import java.util.UUID; //author: 悟空非空也（B站/知乎/公众号） @Controller public class FileController { @GetMapping(\"/upload\") public String upload(){ return \"upload\"; } @PostMapping(\"/uploadFile\") public String uploadFile( @RequestParam(\"fileUpload\") MultipartFile[] uploadFiles, Model model, HttpServletRequest request){ model.addAttribute(\"uploadStatus\",\"文件上传成功\"); for (MultipartFile file : uploadFiles) { String originalFilename = file.getOriginalFilename();// 获得文件名及后缀，例如 wukong.jpg //重新命名 String newFilename = UUID.randomUUID() +\"-\"+ originalFilename; // 创建上传文件的存放目录 :设置为tomcat服务器中的路径 String newPath = request.getServletContext().getRealPath(\"/upload\"); System.out.println(newPath); // String newPath =\"D:\\\\upload\"; File file1 = new File(newPath); if (!file1.exists()){ file1.mkdir(); } //创建新文件，接受传递过来的文件流 try { file.transferTo(new File(newPath,newFilename)); } catch (IOException e) { e.printStackTrace(); model.addAttribute(\"uploadStatus\",\"上传失败\"); } } return \"upload\"; } } upload.html 动态添加文件上传列表 --> --> 上传成功 上传文件:&nbsp;&nbsp; // 动态添加上传按钮 function add(){ var innerdiv = \"\"; innerdiv += \"\" + \"\"; innerdiv +=\"\"; $(\"#file\").append(innerdiv); // 打开上传按钮 $(\"#submit\").css(\"display\",\"block\"); } // 删除当前行 function remove(obj) { $(obj).parent().remove(); if($(\"#file div\").length ==0){ $(\"#submit\").css(\"display\",\"none\"); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/file-upload.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-19 17:22:54 "},"web-dev/file-download.html":{"url":"web-dev/file-download.html","title":"文件下载","keywords":"","body":"文件下载 pom.xml commons-fileupload commons-fileupload 1.3.3 controller package com.wukongnotnull.controller; import org.apache.commons.io.FileUtils; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpStatus; import org.springframework.http.MediaType; import org.springframework.http.ResponseEntity; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RequestMapping; import javax.servlet.http.HttpServletRequest; import java.io.File; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.net.URLEncoder; //author: 悟空非空也（B站/知乎/公众号） @Controller public class FileController { @GetMapping(\"/download\") public String downloadShow(){ return \"download\"; } @RequestMapping(\"/downloadFile\") public ResponseEntity getdownloadFile(String filename, HttpServletRequest request) { String dirPath= \"/Users/mac/Desktop/download/\"; File file = new File(dirPath, filename); HttpHeaders httpHeaders = new HttpHeaders(); // 通知浏览器以下载方式打开（下载前对文件名进行转码,处理中文名乱码问题） filename=this.getFilename(request,filename); httpHeaders.setContentDispositionFormData(\"attachment\" ,filename); httpHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM); ResponseEntity responseEntity =null; try { responseEntity = new ResponseEntity<>(FileUtils.readFileToByteArray(file), httpHeaders, HttpStatus.OK); } catch (IOException e) { responseEntity = new ResponseEntity<>(e.getMessage().getBytes(), HttpStatus.EXPECTATION_FAILED); e.printStackTrace(); } return responseEntity; } // 根据浏览器的不同进行编码设置，返回编码后的文件名 private String getFilename(HttpServletRequest request, String filename) { // IE不同版本User-Agent中出现的关键词 String[] IEBrowserKeyWords = {\"MSIE\", \"Trident\", \"Edge\"}; // 获取请求头代理信息 String userAgent = request.getHeader(\"User-Agent\"); String newFilename= null; try { for (String keyWord : IEBrowserKeyWords) { if (userAgent.contains(keyWord)) { //IE内核浏览器，统一为UTF-8编码显示，并对转换的+进行更正 return URLEncoder.encode(filename, \"UTF-8\").replace(\"+\",\" \"); } } newFilename = new String(filename.getBytes(\"UTF-8\"), \"ISO-8859-1\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } //火狐等其它浏览器统一为ISO-8859-1编码显示 return newFilename; } } html 文件下载 文件下载列表： wukong.rtf 下载文件 悟空.rtf 下载文件 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/file-download.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-20 13:35:15 "},"web-dev/jar-package.html":{"url":"web-dev/jar-package.html","title":"jar 打包部署","keywords":"","body":"jar包方式打包部署 maven打包插件 org.springframework.boot spring-boot-maven-plugin 点击package 保存路径 部署后就可以访问 java -jar target\\myspringboot-mybatis-0.0.1-SNAPSHOT.jar 注意 使用 java 指令，需要配置java的环境变量 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/jar-package.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-20 13:37:03 "},"web-dev/war-package.html":{"url":"web-dev/war-package.html","title":"war 打包部署","keywords":"","body":"war包方式打包部署 pom.xml war 修改启动类 @SpringBootApplication public class MyspringbootMybatisApplication extends SpringBootServletInitializer { //继承SpringbootServletInitializer ,重写configure方法 protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) { return builder.sources(MyspringbootMybatisApplication.class); } public static void main(String[] args) { SpringApplication.run(MyspringbootMybatisApplication.class, args); } } 打包 部署到外部的tomcat的webapp内 启动tomcat部署成功 bin\\startup.bat指令 注意 Jar 包内嵌服务器（Tomcat），war包不含服务器，需要外部服务器才能运行 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/web-dev/war-package.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-20 14:05:44 "},"fore-end-separation/fore-end-separation.html":{"url":"fore-end-separation/fore-end-separation.html","title":"前后端分离","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/fore-end-separation/fore-end-separation.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 10:43:55 "},"fore-end-separation/interface-design.html":{"url":"fore-end-separation/interface-design.html","title":"接口设计","keywords":"","body":"4.2 设置请求映射规则@RequestMapping ​ 该注解可以加到方法上或者是类上。（查看其源码可知） ​ 我们可以用其来设定所能匹配请求的要求。只有符合了设置的要求，请求才能被加了该注解的方法或类处理。 4.2.1 指定请求路径 ​ path或者value属性都可以用来指定请求路径。 例如： ​ 我们期望让请求的资源路径为/test/testPath的请求能够被testPath方法处理则可以写如下代码 @RestController @RequestMapping(\"/test\") public class HelloController { @RequestMapping(\"/testPath\") public String testPath(){ return \"testPath\"; } } @RestController public class HelloController { @RequestMapping(\"/test/testPath\") public String testPath(){ return \"testPath\"; } } 4.2.2 指定请求方式 ​ method属性可以用来指定可处理的请求方式。 例如： ​ 我们期望让请求的资源路径为/test/testMethod的POST请求能够被testMethod方法处理。则可以写如下代码 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testMethod\",method = RequestMethod.POST) public String testMethod(){ System.out.println(\"testMethod处理了请求\"); return \"testMethod\"; } } 注意：我们可以也可以运用如下注解来进行替换 ​ @PostMapping 等价于 @RequestMapping(method = RequestMethod.POST) ​ @GetMapping 等价于 @RequestMapping(method = RequestMethod.GET) ​ @PutMapping 等价于 @RequestMapping(method = RequestMethod.PUT) ​ @DeleteMapping 等价于 @RequestMapping(method = RequestMethod.DELETE) 例如： ​ 上面的需求我们可以使用下面的写法实现 @RestController @RequestMapping(\"/test\") public class TestController { @PostMapping(value = \"/testMethod\") public String testMethod(){ System.out.println(\"testMethod处理了请求\"); return \"testMethod\"; } } 4.2.3 指定请求参数 ​ 我们可以使用params属性来对请求参数进行一些限制。可以要求必须具有某些参数，或者是某些参数必须是某个值，或者是某些参数必须不是某个值。 例如： ​ 我们期望让请求的资源路径为/test/testParams的GET请求,并且请求参数中具有code参数的请求能够被testParams方法处理。则可以写如下代码 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testParams\",method = RequestMethod.GET,params = \"code\") public String testParams(){ System.out.println(\"testParams处理了请求\"); return \"testParams\"; } } ​ ​ 如果是要求不能有code这个参数可以把改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testParams\",method = RequestMethod.GET,params = \"!code\") public String testParams(){ System.out.println(\"testParams处理了请求\"); return \"testParams\"; } } ​ ​ 如果要求有code这参数，并且这参数值必须是某个值可以改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testParams\",method = RequestMethod.GET,params = \"code=sgct\") public String testParams(){ System.out.println(\"testParams处理了请求\"); return \"testParams\"; } } ​ 如果要求有code这参数，并且这参数值必须不是某个值可以改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testParams\",method = RequestMethod.GET,params = \"code!=sgct\") public String testParams(){ System.out.println(\"testParams处理了请求\"); return \"testParams\"; } } 4.2.4 指定请求头 ​ 我们可以使用headers属性来对请求头进行一些限制。 例如： ​ 我们期望让请求的资源路径为/test/testHeaders的GET请求,并且请求头中具有deviceType的请求能够被testHeaders方法处理。则可以写如下代码 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testHeaders\",method = RequestMethod.GET,headers = \"deviceType\") public String testHeaders(){ System.out.println(\"testHeaders处理了请求\"); return \"testHeaders\"; } } ​ 如果是要求不能有deviceType这个请求头可以把改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testHeaders\",method = RequestMethod.GET,headers = \"!deviceType\") public String testHeaders(){ System.out.println(\"testHeaders处理了请求\"); return \"testHeaders\"; } } ​ 如果要求有deviceType这个请求头，并且其值必须是某个值可以改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testHeaders\",method = RequestMethod.GET,headers = \"deviceType=ios\") public String testHeaders(){ System.out.println(\"testHeaders处理了请求\"); return \"testHeaders\"; } } ​ 如果要求有deviceType这个请求头，并且其值必须不是某个值可以改成如下形式 @RestController @RequestMapping(\"/test\") public class TestController { @RequestMapping(value = \"/testHeaders\",method = RequestMethod.GET,headers = \"deviceType!=ios\") public String testHeaders(){ System.out.println(\"testHeaders处理了请求\"); return \"testHeaders\"; } } 4.2.5 指定请求头Content-Type ​ 我们可以使用consumes属性来对Content-Type这个请求头进行一些限制。 范例一 ​ 我们期望让请求的资源路径为/test/testConsumes的POST请求,并且请求头中的Content-Type头必须为 multipart/from-data 的请求能够被testConsumes方法处理。则可以写如下代码 @RequestMapping(value = \"/testConsumes\",method = RequestMethod.POST,consumes = \"multipart/from-data\") public String testConsumes(){ System.out.println(\"testConsumes处理了请求\"); return \"testConsumes\"; } 范例二 ​ 如果我们要求请求头Content-Type的值必须不能为某个multipart/from-data则可以改成如下形式： @RequestMapping(value = \"/testConsumes\",method = RequestMethod.POST,consumes = \"!multipart/from-data\") public String testConsumes(){ System.out.println(\"testConsumes处理了请求\"); return \"testConsumes\"; } 4.3 获取请求参数 4.3.1 Restfull风格路径中请求参数 ​ RestFul风格的接口一些参数是在请求路径上的。类似： /user/1 这里的1就是id。 ​ 如果我们想获取这种格式的数据可以使用@PathVariable来实现。 范例一 ​ 要求定义个RestFul风格的接口，该接口可以用来根据id查询用户。请求路径要求为 /user ，请求方式要求为GET。 ​ 而请求参数id要写在请求路径上，例如 /user/1 这里的1就是id。 ​ 我们可以定义如下方法，通过如下方式来获取路径参数： @RestController public class UserController { @RequestMapping(value = \"/user/{id}\",method = RequestMethod.GET) public String findUserById( @PathVariable(\"id\")Integer id){ System.out.println(\"findUserById\"); System.out.println(id); return \"findUserById\"; } } 范例二 ​ 如果这个接口，想根据id和username查询用户。请求路径要求为 /user ，请求方式要求为GET。 ​ 而请求参数id和name要写在请求路径上，例如 /user/1/zs 这里的1就是id，zs是name ​ 我们可以定义如下方法，通过如下方式来获取路径参数： @RestController public class UserController { @RequestMapping(value = \"/user/{id}/{name}\",method = RequestMethod.GET) public String findUser(@PathVariable(\"id\") Integer id,@PathVariable(\"name\") String name){ System.out.println(\"findUser\"); System.out.println(id); System.out.println(name); return \"findUser\"; } } 4.3.2 请求体中的 json 参数 ​ RestFul风格的接口一些比较复杂的参数会转换成Json通过请求体传递过来。这种时候我们可以使用@RequestBody注解获取请求体中的数据。 4.3.2.1 配置 ​ SpringBoot的web启动器已经默认导入了jackson的依赖，不需要再额外导入依赖了。 4.3.2.2 使用 范例一 ​ 要求定义个RestFul风格的接口，该接口可以用来新建用户。请求路径要求为 /user ，请求方式要求为POST。 用户数据会转换成json通过请求体传递。 ​ 请求体数据 {\"name\":\"wukongnotnull\",\"age\":18} ​ 1.获取参数封装成实体对象 ​ 如果我们想把Json数据获取出来封装User对象,我们可以这样定义方法： @RestController public class UserController { @RequestMapping(value = \"/user\",method = RequestMethod.POST) public String insertUser(@RequestBody User user){ System.out.println(\"insertUser\"); System.out.println(user); return \"insertUser\"; } } ​ User实体类如下： @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private Integer age; } ​ 2.获取参数封装成Map集合 ​ 也可以把该数据获取出来封装成Map集合： @RequestMapping(value = \"/user\",method = RequestMethod.POST) public String insertUser(@RequestBody Map map){ System.out.println(\"insertUser\"); System.out.println(map); return \"insertUser\"; } 范例二 ​ 如果请求体传递过来的数据是一个User集合转换成的json，Json数据可以这样定义： [{\"name\":\"悟空\",\"age\":100},{\"name\":\"猪八戒\",\"age\":200},{\"name\":\"唐僧\",\"age\":30}] ​ 方法定义： @RequestMapping(value = \"/users\",method = RequestMethod.POST) public String insertUsers(@RequestBody List users){ System.out.println(\"insertUsers\"); System.out.println(users); return \"insertUser\"; } 4.3.2.3 注意事项 ​ 如果需要使用@RequestBody来获取请求体中Json并且进行转换，要求请求头 Content-Type 的值要为： application/json 。 4.3.3 获取 QueryString 格式参数 ​ 如果接口的参数是使用QueryString的格式的话，我们也可以使用SpringMVC快速获取参数。 ​ 我们可以使用@RequestParam来获取QueryString格式的参数。 4.3.3.1 使用 范例一 ​ 要求定义个接口，该接口请求路径要求为 /testRequestParam，请求方式无要求。参数为id和name和likes。使用QueryString的格式传递。 1.参数单独的获取 ​ 如果我们想把id，name，likes单独获取出来可以使用如下写法： ​ 在方法中定义方法参数，方法参数名要和请求参数名一致，这种情况下我们可以省略@RequestParam注解。 @RequestMapping(\"/testRquestParam\") public String testRquestParam(Integer id, String name, String[] likes){ System.out.println(\"testRquestParam\"); System.out.println(id); System.out.println(name); System.out.println(Arrays.toString(likes)); return \"testRquestParam\"; } ​ 如果方法参数名和请求参数名不一致，我们可以加上@RequestParam注解例如： @RequestMapping(\"/testRquestParam\") public String testRquestParam(@RequestParam(\"id\") Integer uid,@RequestParam(\"name\") String name, @RequestParam(\"likes\")String[] likes){ System.out.println(\"testRquestParam\"); System.out.println(uid); System.out.println(name); System.out.println(Arrays.toString(likes)); return \"testRquestParam\"; } 2.获取参数封装成实体对象 ​ 如果我们想把这些参数封装到一个User对象中可以使用如下写法： @RequestMapping(\"/testRquestParam\") public String testRquestParam(User user){ System.out.println(\"testRquestParam\"); System.out.println(user); return \"testRquestParam\"; } ​ User类定义如下： @Data @NoArgsConstructor @AllArgsConstructor public class User { private Integer id; private String name; private Integer age; private String[] likes; } ​ 测试时请求url如下： http://localhost:8080/testRquestParam?id=1&name=wukongnotnull&likes=eat&likes=drink&likes=play ​ 注意：实体类中的成员变量要和请求参数名对应上。并且要提供对应的set/get方法。 4.3.4 相关注解其他属性 4.3.4.1 required ​ 代表是否必须，默认值为true也就是必须要有对应的参数。如果没有就会报错。 ​ 如果对应的参数可传可不传则可以把其设置为fasle 例如： @RequestMapping(\"/testRquestParam\") public String testRquestParam(@RequestParam(value = \"id\",required = false) Integer uid,@RequestParam(\"name\") String name, @RequestParam(\"likes\")String[] likes){ System.out.println(\"testRquestParam\"); System.out.println(uid); System.out.println(name); System.out.println(Arrays.toString(likes)); return \"testRquestParam\"; } 4.3.4.2 defaultValue ​ 如果对应的参数没有，我们可以用defaultValue属性设置默认值。 例如： @RequestMapping(\"/testRquestParam\") public String testRquestParam(@RequestParam(value = \"id\",required = false,defaultValue = \"777\") Integer uid,@RequestParam(\"name\") String name, @RequestParam(\"likes\")String[] likes){ System.out.println(\"testRquestParam\"); System.out.println(uid); System.out.println(name); System.out.println(Arrays.toString(likes)); return \"testRquestParam\"; } 4.4 @ResponseBody ​ 无论是RestFul风格还是我们之前web阶段接触过的异步请求，都需要把返回数据转换成Json放入响应体中。 4.4.1 数据放到响应体 ​ 我们的SpringMVC为我们提供了@ResponseBody来非常方便的把 Json 放到响应体中。 ​ @ResponseBody可以加在哪些东西上面？类上和方法上 ​ 具体代码请参考范例。 4.4.2 数据转换成Json 4.4.2.1 配置 ​ SpringBoot项目中使用了web的start后，不需要进行额外的依赖和配置 4.4.2.2 使用 ​ 只要把要转换的数据直接作为方法的返回值返回即可。SpringMVC会帮我们把返回值转换成json。具体代码请参考范例。 4.4.3 范例 范例一 ​ 要求定义个RestFul风格的接口，该接口可以用来根据id查询用户。请求路径要求为 /response/user ，请求方式要求为GET。 ​ 而请求参数id要写在请求路径上，例如 /response/user/1 这里的1就是id。 ​ 要求获取参数id,去查询对应id的用户信息（模拟查询即可，可以选择直接new一个User对象），并且转换成json响应到响应体中。 @Controller @RequestMapping(\"/response\") public class ResponseController { @RequestMapping(\"/user/{id}\") @ResponseBody public User findById(@PathVariable(\"id\") Integer id){ User user = new User(id, \"三更草堂\", 15, null); return user; } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/fore-end-separation/interface-design.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-05 23:19:26 "},"fore-end-separation/cors.html":{"url":"fore-end-separation/cors.html","title":"CORS 跨域处理","keywords":"","body":" CORS 跨域处理 跨域 浏览器出于安全的考虑，使用 XMLHttpRequest对象发起 HTTP请求时必须遵守同源策略，否则就是跨域的HTTP请求，默认情况下是被禁止的。 同源策略要求源相同才能正常进行通信，即协议、域名、端口号都完全一致。 CORS 解决跨域 CORS是一个W3C标准，全称是”跨域资源共享” Cross-origin resource sharing ，允许浏览器向跨源服务器，发出 XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。 它通过服务器增加一个特殊的 Header[Access-Control-Allow-Origin] 来告诉客户端跨域的限制，如果浏览器支持 CORS ,并且判断Origin通过的话，就会允许XMLHttpRequest发起跨域请求。 SpringBoot 使用 CORS 解决跨域 方法一 @CrossOrigin 方法或者类上添加 @CrossOrigin 注解 @RestController @RequestMapping(\"/user\") @CrossOrigin public class UserController { @Autowired private UserServcie userServcie; @RequestMapping(\"/getUserList\") public ResponseResult getUserList(){ List users = userServcie.getUserList(); return new ResponseResult(200,users); } } 方法二 重写 addCorsMappings 方法 @Configuration public class MyWebMvcConfigurer implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) { // 设置允许跨域的路径 registry.addMapping(\"/**\") // 设置允许跨域请求的域名 .allowedOriginPatterns(\"*\") // 是否允许 cookie .allowCredentials(true) // 设置允许的请求方式 .allowedMethods(\"GET\", \"POST\", \"DELETE\", \"PUT\") // 设置允许的 header 属性 .allowedHeaders(\"*\") // 允许跨域最大时长 .maxAge(3600); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/fore-end-separation/cors.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-06 10:02:22 "},"fore-end-separation/token-login.html":{"url":"fore-end-separation/token-login.html","title":"Token 登录","keywords":"","body":"Token 在前后端分离的场景中，采用 Token 方案进行登录验证。登录成功时，后端根据用户信息生成一个 Token 字符串返回给前端（客户端）存储。 前端再次发送请求时，若存在 token ，会放入请求头中发送给后端。后端进行解析，如果解析不成功（token 超时或者token信息错误），表示为未登录。 原理类似 Session 。 Token 生成方案-JWT 目前企业中运用比较多的，是使用 JWT 技术来生成 token 。 引入依赖 io.jsonwebtoken jjwt 0.9.0 设计工具类来生成和解析token import io.jsonwebtoken.Claims; import io.jsonwebtoken.JwtBuilder; import io.jsonwebtoken.Jwts; import io.jsonwebtoken.SignatureAlgorithm; import javax.crypto.SecretKey; import javax.crypto.spec.SecretKeySpec; import java.util.Base64; import java.util.Date; import java.util.UUID; /** * JWT工具类 */ public class JwtUtil { //有效期为 public static final Long JWT_TTL = 60 * 60 *1000L;// 60 * 60 *1000 一个小时 //设置秘钥明文 public static final String JWT_KEY = \"wukongnotnull\"; /** * 创建token * @param id * @param subject * @param ttlMillis * @return */ public static String createJWT(String id, String subject, Long ttlMillis) { SignatureAlgorithm signatureAlgorithm = SignatureAlgorithm.HS256; long nowMillis = System.currentTimeMillis(); Date now = new Date(nowMillis); if(ttlMillis==null){ ttlMillis=JwtUtil.JWT_TTL; } long expMillis = nowMillis + ttlMillis; Date expDate = new Date(expMillis); SecretKey secretKey = generalKey(); JwtBuilder builder = Jwts.builder() .setId(id) //唯一的ID .setSubject(subject) // 主题 可以是JSON数据 .setIssuer(\"sg\") // 签发者 .setIssuedAt(now) // 签发时间 .signWith(signatureAlgorithm, secretKey) //使用HS256对称加密算法签名, 第二个参数为秘钥 .setExpiration(expDate);// 设置过期时间 return builder.compact(); } /** * 生成加密后的秘钥 secretKey * @return */ public static SecretKey generalKey() { byte[] encodedKey = Base64.getDecoder().decode(JwtUtil.JWT_KEY); SecretKey key = new SecretKeySpec(encodedKey, 0, encodedKey.length, \"AES\"); return key; } /** * 解析 * * @param jwt * @return * @throws Exception */ public static Claims parseJWT(String jwt) throws Exception { SecretKey secretKey = generalKey(); return Jwts.parser() .setSigningKey(secretKey) .parseClaimsJws(jwt) .getBody(); } } 登录接口实现 数据准备 DROP TABLE IF EXISTS `sys_user`; CREATE TABLE `sys_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(50) DEFAULT NULL, `password` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8; /*Data for the table `sys_user` */ insert into `sys_user`(`id`,`username`,`password`) values (1,'root','root'),(2,'sangeng','caotang'); 实体类 @Data @NoArgsConstructor @AllArgsConstructor public class SystemUser { private Integer id; private String username; private String password; } SystemUserController import com.wukongnotnull.domain.ResponseResult; import com.wukongnotnull.domain.SystemUser; import com.wukongnotnull.service.SystemUserService; import com.wukongnotnull.utils.JwtUtil; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestBody; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; import java.util.HashMap; import java.util.Map; import java.util.UUID; @RestController @RequestMapping(\"/sys_user\") public class SystemUserController { @Autowired private SystemUserService userService; @PostMapping(\"/login\") public ResponseResult login(@RequestBody SystemUser user) { //校验用户名密码是否正确 SystemUser loginUser = userService.login(user); Map map; if (loginUser != null) { //如果正确 生成token返回 map = new HashMap<>(); String token = JwtUtil.createJWT(UUID.randomUUID().toString(), String.valueOf(loginUser.getId()), null); map.put(\"token\", token); } else { //如果不正确 给出相应的提示 return new ResponseResult(300, \"用户名或密码错误，请重新登录\"); } return new ResponseResult(200, \"登录成功\", map); } } Service public interface SystemUserService { public SystemUser login(SystemUser user); } @Service public class SystemUserServcieImpl implements SystemUserService { public login(User user){ if() } @Override public SystemUser login(SystemUser user) { SystemUser loginUser = this.login(user); return loginUser; } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/fore-end-separation/token-login.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-04 16:46:44 "},"fore-end-separation/token-authorization.html":{"url":"fore-end-separation/token-authorization.html","title":"Token  授权","keywords":"","body":"拦截器 ​ 如果我们想在多个Handler方法执行之前或者之后都进行一些处理，甚至某些情况下需要拦截掉，不让Handler方法执行。那么可以使用SpringMVC为我们提供的拦截器。 4.6.1 使用步骤 ①创建类实现HandlerInterceptor接口 public class LoginInterceptor implements HandlerInterceptor { } ②实现方法 @Component public class LoginInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { //获取请求头中的token String token = request.getHeader(\"token\"); //判断token是否为空，如果为空也代表未登录 提醒重新登录（401） if(!StringUtils.hasText(token)){ response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } //解析token看看是否成功 try { Claims claims = JwtUtil.parseJWT(token); String subject = claims.getSubject(); System.out.println(subject); } catch (Exception e) { e.printStackTrace(); //如果解析过程中没有出现异常说明是登录状态 //如果出现了异常，说明未登录，提醒重新登录（401） response.sendError(HttpServletResponse.SC_UNAUTHORIZED); return false; } return true; } } ③配置拦截器 @Configuration public class LoginConfig implements WebMvcConfigurer { @Autowired private LoginInterceptor loginInterceptor; @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(loginInterceptor)//添加拦截器 .addPathPatterns(\"/**\") //配置拦截路径 .excludePathPatterns(\"/sys_user/login\");//配置排除路径 } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/fore-end-separation/token-authorization.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-04 17:23:03 "},"fore-end-separation/argument-resolve.html":{"url":"fore-end-separation/argument-resolve.html","title":"自定义参数解析","keywords":"","body":"自定义参数解析 ​ 如果我们想实现像获取请求体中的数据那样，在Handler方法的参数上增加一个@RepuestBody注解就可以获取到对应的数据的话。 ​ 可以使用HandlerMethodArgumentResolver来实现自定义的参数解析。 ①定义用来标识的注解 @Target(ElementType.PARAMETER) @Retention(RetentionPolicy.RUNTIME) public @interface CurrentUserId { } ②创建类实现HandlerMethodArgumentResolver接口并重写其中的方法 注意加上@Component注解注入Spring容器 public class UserIdArgumentResolver implements HandlerMethodArgumentResolver { //判断方法参数使用能使用当前的参数解析器进行解析 @Override public boolean supportsParameter(MethodParameter parameter) { //如果方法参数有加上CurrentUserId注解，就能把被我们的解析器解析 return parameter.hasParameterAnnotation(CurrentUserId.class); } //进行参数解析的方法，可以在方法中获取对应的数据，然后把数据作为返回值返回。方法的返回值就会赋值给对应的方法参数 @Override public Object resolveArgument(MethodParameter parameter, ModelAndViewContainer mavContainer, NativeWebRequest webRequest, WebDataBinderFactory binderFactory) throws Exception { //获取请求头中的token String token = webRequest.getHeader(\"token\"); if(StringUtils.hasText(token)){ //解析token，获取userId Claims claims = JwtUtil.parseJWT(token); String userId = claims.getSubject(); //返回结果 return userId; } return null; } } ③配置参数解析器 @Configuration public class ArgumentResolverConfig implements WebMvcConfigurer { @Autowired private UserIdArgumentResolver userIdArgumentResolver; @Override public void addArgumentResolvers(List resolvers) { resolvers.add(userIdArgumentResolver); } } ④测试 在需要获取UserId的方法中增加对应的方法参数然后使用@CurrentUserId进行标识即可获取到数据 @RestController @RequestMapping(\"/user\") //@CrossOrigin public class UserController { @Autowired private UserServcie userServcie; @RequestMapping(\"/findAll\") public ResponseResult findAll(@CurrentUserId String userId) throws Exception { System.out.println(userId); //调用service查询数据 ，进行返回s List users = userServcie.findAll(); return new ResponseResult(200,users); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/fore-end-separation/argument-resolve.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-05 23:20:47 "},"fore-end-separation/user-management.html":{"url":"fore-end-separation/user-management.html","title":"用户管理 CRUD","keywords":"","body":"集成mybatis springboot 2.x 默认数据源是 Hikari 引入坐标 org.springframework.boot spring-boot-starter-parent 2.4.2 org.springframework.boot spring-boot-starter-web org.mybatis.spring.boot mybatis-spring-boot-starter 2.1.4 com.github.pagehelper pagehelper-spring-boot-starter 1.2.13 mysql mysql-connector-java application.yml # sb2.x 默认数据源Hikari配置 spring: datasource: url: jdbc:mysql://localhost:3306/test?useUnicode=true&characterEncoding=utf8&serverTimezone=GMT%2B8 username: root password: root driver-class-name: com.mysql.cj.jdbc.Driver # mybatis 配置 mybatis: mapper-locations: classpath:/mappers/*.xml configuration: map-underscore-to-camel-case: true type-aliases-package: com.wukong.pojo #分页插件配置 pagehelper: helper-dialect: mysql 启动类 @SpringBootApplication // dao 无 bean对象，使用 @MapperScan 进行扫描 @MapperScan(\"com.wukong.dao\") public class App { public static void main( String[] args ) { SpringApplication.run(App.class); System.out.println( \"Hello World!\" ); } } 需求： 根据用户名查询指定用户 user表中 id 和 username 都要求唯一性 dao 层接口 com.wukong.dao.UserMapper package com.wukong.dao; import com.wukong.pojo.User; public interface UserMapper { public User getUserByUsername(String username); } sql映射文件 resources/mappers/UserMapper.xml select * from user where username = #{username} service public interface UserService { public User getUserByUsername(String username); } ------------分割线------------------ @Service public class UserServiceImpl implements UserService { @Autowired private UserMapper userMapper; @Override public User getUserByUsername(String username) { return this.userMapper.getUserByUsername(username); } } controller @RestController public class UserController { @Autowired private UserService userService; @GetMapping(\"/user/{username}\") public User getUserByUsername(@PathVariable String username){ return this.userService.getUserByUsername(username); } } 需求： 根据id查询指定用户 上述需求和本需求都是get请求方式，要留意请求路径的区分，不然会报错 controller @RestController @RequestMapping(\"/user\") public class UserController { @Autowired private UserService userService; @GetMapping(\"/{username}\") public User getUserByUsername(@PathVariable String username){ return this.userService.getUserByUsername(username); } // 可以多添加 id 路径字段 区分 @GetMapping(\"/id/{id}\") public Object getUserById(@PathVariable Integer id){ return this.userService.getUserById(id); } } 需求： 添加用户 要求： 添加用户字段 非空 用户名不能重复 引入坐标 org.apache.commons commons-lang3 工具类 ParamsException 作用： 自定义异常，遇到字段为空，用户名重复等属性错误时，抛出异常。 package com.wukong.utils; /** * author: 悟空非空也（B站/知乎/公众号） */ public class ParamsException extends RuntimeException { private Integer code = 300; private String msg = \"默认参数异常提示\"; public ParamsException(){ super(); } public ParamsException(Integer code){ this.code = code; } public ParamsException(String msg) { this.msg = msg; } public ParamsException(Integer code, String msg) { this.code = code; this.msg = msg; } public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } } AssertUtil 提示语工具类，用于显示不同情况下，返回不同的提示语 package com.wukong.utils; /** * author: 悟空非空也（B站/知乎/公众号） */ /** * 提示语工具类 */ public class AssertUtil { public static void isTrue(boolean flag, Integer code, String message) { if (flag) { throw new ParamsException(code, message); } System.out.println(); } } dao & sql 映射文件 public interface UserMapper { public int addUser(User user); } insert into user (username, password) values (#{username}, #{password}) service public void addUser(User user); /** * 字段非空判断 * username 不能重复 */ public void addUser(User user) { AssertUtil.isTrue(StringUtils.isBlank(user.getUsername()),301,\"用户名为空，请重新输入\"); AssertUtil.isTrue(StringUtils.isBlank(user.getPassword()),302,\"密码为空，请重新输入\"); AssertUtil.isTrue(userMapper.getUserByUsername(user.getUsername()) !=null,303,\"用户名重复，请重新输入\"); int i = userMapper.addUser(user); AssertUtil.isTrue(i vo/ResultInfo 响应给视图层的数据，进行自定义封装。 package com.wukong.vo; /* author: 悟空非空也（B站/知乎/公众号） */ public class ResultInfo { private Integer code = 200; private String msg = \"操作成功\"; private Object data; public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } } controller @PostMapping(\"/user\") public Object addUser(@RequestBody User user){ ResultInfo resultInfo = new ResultInfo(); try{ this.userService.addUser(user); }catch (ParamsException paramsException){ resultInfo.setCode(paramsException.getCode()); resultInfo.setMsg(paramsException.getMsg()); }catch (Exception e){ e.printStackTrace(); } return resultInfo; } postman 进行测试 需求： 修改用户 要求： id字段 不能为空。 username 字段 修改后的新名字，可以同原名，但是不能同其他用户信息的用户名。同时，字段不能为空。 password 不能为空。 dao & sql 映射文件 public int modifyUser(User user); update user set username = #{username}, password = #{password} where id = #{id} service public void modifyUser(User user); @Override public void modifyUser(User user) { //非空判断 AssertUtil.isTrue(StringUtils.isBlank(user.getUsername()),301,\"用户名为空，请重新输入\"); AssertUtil.isTrue(StringUtils.isBlank(user.getPassword()),302,\"密码为空，请重新输入\"); AssertUtil.isTrue(user.getId() == null,305,\"用户id为空\"); //username 不能已存在，除了自己 User userByUsername = this.userMapper.getUserByUsername(user.getUsername()); AssertUtil.isTrue(userByUsername != null && !user.getId().equals(userByUsername.getId()),303,\"用户名重复，请重新输入\"); //修改用户信息 int i = userMapper.modifyUser(user); AssertUtil.isTrue(i controller @PutMapping(\"/user\") public Object modifyUser(@RequestBody User user){ ResultInfo resultInfo = new ResultInfo(); try { this.userService.modifyUser(user); } catch (ParamsException e){ resultInfo.setCode(e.getCode()); resultInfo.setMsg(e.getMsg()); } catch (Exception e) { e.printStackTrace(); } return resultInfo; } 需求： 删除用户 dao & sql 映射语句 public int deleteUser(Integer id); delete from user where id = #{id} service public void deleteUser(Integer id) { //非空判断 AssertUtil.isTrue(id == null,305,\"用户id为空\"); //是否存在该用户 this.getUserById(id); //删除用户 int i = this.userMapper.deleteUser(id); AssertUtil.isTrue(i controller @DeleteMapping(\"/user/{id}\") public Object deleteUser(@PathVariable Integer id) { ResultInfo resultInfo = new ResultInfo(); try { this.userService.deleteUser(id); } catch (ParamsException e){ resultInfo.setCode(e.getCode()); resultInfo.setMsg(e.getMsg()); } catch (Exception e) { e.printStackTrace(); } return resultInfo; } 需求： 查询用户分页列表 坐标 com.github.pagehelper pagehelper-spring-boot-starter 1.2.13 application.yml #分页插件配置 pagehelper: helper-dialect: mysql bo/UserParams 实体类 package com.wukong.bo; /* author: 悟空非空也（B站/知乎/公众号） */ public class UserParams { private Integer pageNum = 1; //当前页 private Integer pageSize = 3; //页容量（每页包含多少记录） private String username; public Integer getPageNum() { return pageNum; } public void setPageNum(Integer pageNum) { this.pageNum = pageNum; } public Integer getPageSize() { return pageSize; } public void setPageSize(Integer pageSize) { this.pageSize = pageSize; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } } dao & sql 映射文件 public List getUserList(UserParams userParams); select * from user and username like CONCAT('%',#{username},'%') service public PageInfo getUserPageList(UserParams userParams); public PageInfo getUserPageList(UserParams userParams) { PageHelper.startPage(userParams.getPageNum(), userParams.getPageSize()); return new PageInfo(this.userMapper.getUserList(userParams)); } controller @GetMapping(\"/user/list\") public PageInfo getUserPageList(@RequestBody UserParams userParams){ return this.userService.getUserPageList(userParams); } postman 测试 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/fore-end-separation/user-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 10:58:18 "},"Integrated-swagger/integrated-swagger.html":{"url":"Integrated-swagger/integrated-swagger.html","title":"Api文档 Swagger","keywords":"","body":"Swagger2 文档构建工具 由于Spring Boot能够快速开发、便捷部署等特性，通常在使用Spring Boot构建Restful 接口应用时考虑到多终端的 原因，这些终端会共用很多底层业务逻辑，因此我们会抽象出这样一层来同时服务于多个移动端或者Web前端。对于 不同的终端公用一套接口API时对于联调测试时就需要知道后端提供的接口Api 列表文档，对于服务端开发人员来说 就需要编写接口文档，描述接口调用地址参数结果等，这里借助第三方构建工具Swagger2来实现Api文档生成功能 。 引入依赖 io.springfox springfox-swagger2 2.9.2 io.springfox springfox-swagger-ui 2.9.2 配置类 package com.wukongnotnull.config; /* author: 悟空非空也（B站/知乎/公众号） */ import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import springfox.documentation.builders.RequestHandlerSelectors; import springfox.documentation.service.ApiInfo; import springfox.documentation.service.Contact; import springfox.documentation.spi.DocumentationType; import springfox.documentation.spring.web.plugins.Docket; import springfox.documentation.swagger2.annotations.EnableSwagger2; import java.util.ArrayList; @Configuration @EnableSwagger2 public class Swagger2Config { @Bean public Docket createDocket() { return new Docket(DocumentationType.SWAGGER_2) .apiInfo(this.apiInfo()) .select() //根据基包路径选择接口 .apis(RequestHandlerSelectors.basePackage(\"com.wukongnotnull.controller\")) .build(); } //配置文档信息 private ApiInfo apiInfo() { Contact contact = new Contact(\"悟空非空也\", \"http://www.huaguoshan.tech\", \"1390128154@qq.com\"); return new ApiInfo( \"悟空的项目api文档\", // 标题 \"实现对用户模块的增删改查\", // 描述 \"v1.0\", // 版本 \"http://terms.service.url/组织链接\", // 组织链接 contact, // 联系人信息 \"Apach 2.0 许可\", // 许可 \"许可链接\", // 许可连接 new ArrayList<>()// 扩展 ); } } // 根据包路径选择接口 basePackage(final String basePackage) // 选择所有接口 any() // 不选择接口 none() // 根据 method 的注解选择，如 withMethodAnnotation(GetMapping.class) 只扫描 GET 请求 withMethodAnnotation(final Class annotation) // 根据类上的注解选择，如.withClassAnnotation(Controller.class)只选择 controller注解类中的接口 withClassAnnotation(final Class annotation) 访问路径 wukong 为项目名 http://localhost:8081/wukong/swagger-ui.html controller package com.wukongnotnull.controller; import com.github.pagehelper.PageInfo; import com.wukong.bo.UserParams; import com.wukong.pojo.User; import com.wukong.service.UserService; import com.wukong.utils.ParamsException; import com.wukong.vo.ResultInfo; import io.swagger.annotations.*; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.*; @RestController @Api(tags = \"我是用户控制器\") public class UserController { @Autowired private UserService userService; @GetMapping(\"/user/{username}\") @ApiOperation(value =\"getUserByUsername接口\",notes = \"根据用户名查询用户\") @ApiImplicitParam( name = \"username\", value = \"用户名\", required = true, dataType = \"String\", defaultValue = \"默认值是。。。\", paramType = \"path\" ) public User getUserByUsername(@PathVariable String username){ return this.userService.getUserByUsername(username); } @GetMapping(\"/user/id/{id}\") @ApiOperation(value = \"getUserById接口\", notes = \"根据id查询用户\") @ApiImplicitParam(name = \"id\", value = \"用户id字段\", required = true,dataType = \"Integer\", paramType = \"path\",defaultValue = \"默认值为...\" ) public Object getUserById(@PathVariable Integer id){ ResultInfo resultInfo = new ResultInfo(); User userById =null; 。。。。 。。。。 return resultInfo; } @PostMapping(\"/user\") @ApiOperation(value = \"addUser接口\", notes = \"实现添加用户\") @ApiImplicitParam( name = \"user\", value = \"User对象\", dataType = \"User\", paramType = \"body\", defaultValue = \"默认值...\" ) public Object addUser(@RequestBody User user){ ResultInfo resultInfo = new ResultInfo(); try{ this.userService.addUser(user); }catch (ParamsException paramsException){ resultInfo.setCode(paramsException.getCode()); resultInfo.setMsg(paramsException.getMsg()); }catch (Exception e){ e.printStackTrace(); } return resultInfo; } @PutMapping(\"/user\") @ApiOperation(value = \"modifyUser接口\", notes = \"实现用户信息的修改\") @ApiImplicitParam( name = \"user\",value = \"User对象\",required = true, dataType = \"User\",paramType = \"body\", defaultValue = \"默认值为...\" ) public Object modifyUser(@RequestBody User user){ ResultInfo resultInfo = new ResultInfo(); try { this.userService.modifyUser(user); } catch (ParamsException e){ resultInfo.setCode(e.getCode()); resultInfo.setMsg(e.getMsg()); } catch (Exception e) { e.printStackTrace(); } return resultInfo; } @DeleteMapping(\"/user/{id}\") @ApiOperation(value = \"deleteUser接口\", notes = \"删除用户的功能\") @ApiImplicitParam( name = \"id\",value = \"用户id\", defaultValue = \"默认值...\", required = true, dataType = \"Integer\",paramType = \"path\" ) public ResultInfo deleteUser(@PathVariable Integer id) { ResultInfo resultInfo = new ResultInfo(); try { this.userService.deleteUser(id); } catch (ParamsException e){ resultInfo.setCode(e.getCode()); resultInfo.setMsg(e.getMsg()); } catch (Exception e) { e.printStackTrace(); } return resultInfo; } @GetMapping(\"/user/list\") @ApiOperation(value = \"getUserPageList接口\", notes = \"分页查询用户列表\") /*@ApiImplicitParam(name = \"userParams\", value = \"用户查询条件\") 不要写 */ public PageInfo getUserPageList( UserParams userParams){ return this.userService.getUserPageList(userParams); } } model package com.wukongnotnull.pojo; import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; @ApiModel(description = \"User实体类\") public class User { // 当类型为Integer类型时候, example 必须要写 @ApiModelProperty(name = \"id\",value = \"用户id\",example = \"1\") private Integer id; @ApiModelProperty(name = \"username\",value = \"用户名\") private String username; @ApiModelProperty(name = \"password\",value = \"用户密码\") private String password; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } package com.wukongnotnull.vo; /* author: 悟空非空也（B站/知乎/公众号） */ import io.swagger.annotations.ApiModel; import io.swagger.annotations.ApiModelProperty; @ApiModel(description = \"响应对象\") public class ResultInfo { @ApiModelProperty(name = \"code\",value = \"状态码\",example = \"200\") private Integer code = 200; @ApiModelProperty(name = \"msg\",value = \"响应信息\") private String msg = \"操作成功\"; @ApiModelProperty(name = \"data\", value = \"响应数据\") private Object data; public Integer getCode() { return code; } public void setCode(Integer code) { this.code = code; } public String getMsg() { return msg; } public void setMsg(String msg) { this.msg = msg; } public Object getData() { return data; } public void setData(Object data) { this.data = data; } } 分环境显示文档 动态配置当项目处于test、dev环境时显示swagger，处于prod时不显示 @Bean public Docket docket(Environment environment) { // 设置要显示swagger的环境 Profiles of = Profiles.of(\"dev\", \"test\"); // 通过 enable() 接收此参数判断是否要显示 boolean flag = environment.acceptsProfiles(of); return new Docket(DocumentationType.SWAGGER_2) .apiInfo(apiInfo()) .enable(flag) //是否启用 Swagger ，false 为浏览器无法访问 .select() .apis(RequestHandlerSelectors.basePackage(\"com.wukongnotnull.controller\")) // 通过请求路径再过滤 .paths(PathSelectors.ant(\"/wukong/**\")) .build(); } 文档分组展示 接口文档根据不同开发者进行分组展示，开发者分别是 wukong , zhubajie , shaseng 默认组名为 default ,通过 groupName() 可配置分组 @Bean public Docket docket() { return new Docket(DocumentationType.SWAGGER_2).apiInfo(apiInfo()) .groupName(\"wukong\") // 配置分组 // 省略配置.... } 配置多个分组 @Bean public Docket docket1(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"zhubajie\"); } @Bean public Docket docket2(){ return new Docket(DocumentationType.SWAGGER_2).groupName(\"shaseng\"); } UI 界面拓展 默认的UI 访问 http://localhost:8080/swagger-ui.html io.springfox springfox-swagger-ui 2.9.2 bootstrap-ui 访问 http://localhost:8080/doc.html com.github.xiaoymin swagger-bootstrap-ui 1.9.1 Layui-ui 访问 http://localhost:8080/docs.html com.github.caspar-chen swagger-ui-layer 1.1.3 mg-ui 访问 http://localhost:8080/document.html com.zyplayer swagger-mg-ui 1.0.6 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/Integrated-swagger/integrated-swagger.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 16:11:17 "},"cache-management/cache-management.html":{"url":"cache-management/cache-management.html","title":"缓存管理","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/cache-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 10:00:06 "},"cache-management/env-setup.html":{"url":"cache-management/env-setup.html","title":"基础环境搭建","keywords":"","body":"基础环境搭建 创建项目 pom.xml org.springframework.boot spring-boot-starter-data-jpa org.springframework.boot spring-boot-starter-web org.springframework.boot spring-boot-devtools runtime true mysql mysql-connector-java runtime org.projectlombok lombok true 配置文件配置 #mysql数据库连接配置 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/wukong_blog?serverTimezone=UTC&useUnicode=true&characterEncoding=utf8&autoReconnect=true username: root password: rootroot # 显示 sql 语句 jpa: show-sql: true 实体类 import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; @Data @NoArgsConstructor @AllArgsConstructor @Entity(name = \"b_comment\") public class Comment { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"content\") private String content; @Column(name = \"author\") private String author; @Column(name = \"article_id\") private Integer articleId; } 编写自定义仓库类，继承JpaRepository package com.wukongnotnull.repository; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import javax.transaction.Transactional; import java.util.List; import java.util.Optional; public interface CommentRepository extends JpaRepository { @Override List findAll(); @Override Optional findById(Integer id); // 查询条件：作者不为空 List findByAuthorNotNull(); @Override long count(); @Override S saveAndFlush(S s); @Query(\"select c from b_comment c where c.articleId=?1\") List getCommentList(Integer articleId); @Query(value = \"select * from b_comment c where c.article_id=?1\",nativeQuery = true) List getCommentList2(Integer articleId); @Transactional @Modifying @Query(value = \"update b_comment set author =?1 where id =?2 \",nativeQuery = true) int updateComment(String author,Integer id); @Transactional @Modifying @Query(value = \"delete from b_comment where id = ?1\",nativeQuery = true) int deleteComment(Integer id); @Override S save(S entity); } service层 package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import java.util.Optional; public interface CommentService { //add public Comment addComment(Comment comment); //delete public void deleteComment(Integer id); //modify public int modifyComment(Integer id,String author); //query public Comment findById(Integer id); } package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); } //query public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } controller层 package com.wukongnotnull.controller; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.service.CommentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RestController; @RestController public class CommentController { @Autowired private CommentService commentService; //query @GetMapping(\"/query/{id}\") public Comment findById(@PathVariable(\"id\") Integer id){ return this.commentService.findById(id); } //modify @GetMapping(\"/modify/{id}/{author}\") public int modifyBy(@PathVariable(\"id\") Integer id,@PathVariable(\"author\") String author){ int i = this.commentService.modifyComment(id, author); return i; } //delete @GetMapping(\"/delete/{id}\") public void deleteById(@PathVariable(\"id\") Integer id){ this.commentService.deleteComment(id); } //add } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/env-setup.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-20 14:49:50 "},"cache-management/default-cache.html":{"url":"cache-management/default-cache.html","title":"默认缓存","keywords":"","body":"Spring Boot默认缓存体验 spring boot 自带缓存机制，可以使用默认缓存，避免每次查询都去数据库访问一边，避免资源消耗 在启动类上添加注解 @EnableCaching package com.wukongnotnull; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cache.annotation.EnableCaching; @SpringBootApplication @EnableCaching //开启springboot默认缓存 public class RedisSpringbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSpringbootApplication.class, args); } } 在service层的实现类的方法上添加注解 @Cacheable，开启缓存空间 package com.wukongnotnull.service; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); } //query @Cacheable(cacheNames = \"comment\")//创建缓存空间，并命名为comment public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } 测试，多次查询，在控制台只打印第一次查询日志 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/default-cache.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-20 15:14:16 "},"cache-management/integrate-redis.html":{"url":"cache-management/integrate-redis.html","title":"redis 缓存","keywords":"","body":"Redis 缓存介绍 基于注解的 Redis 缓存实现 pom中添加redis的依赖启动器 org.springframework.boot spring-boot-starter-data-redis 配置redis的连接配置 #redis数据库的连接配置 spring: redis: host: 127.0.0.1 port: 6379 password: 启动类上添加注解@EnableCaching @SpringBootApplication @EnableCaching//开启springboot默认缓存 public class RedisSprongbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSprongbootApplication.class, args); } } service层上对删改查操作添加redis缓存注解 增加功能直接插入mysql数据库 package com.wukongnotnull.repository; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.cache.annotation.CacheEvict; import org.springframework.cache.annotation.CachePut; import org.springframework.cache.annotation.Cacheable; import org.springframework.stereotype.Service; import java.util.Optional; @Service public class CommentServiceImpl implements CommentService { @Autowired public CommentRepository commentRepository; //add public Comment addComment(Comment comment){ return this.commentRepository.save(comment); } //delete @CacheEvict(cacheNames = \"comment\")//删除使用@CacheEvict public void deleteComment(Integer id){ this.commentRepository.deleteById(id); } //modify @CachePut(cacheNames = \"comment\",key =\"#result.id\")//更新使用，@CachePut,此处返回类型不能为int，因为缓存数据库中为int，再次查询需要的是Comment /* public int modifyComment(Integer id,String author){ return this.commentRepository.updateComment(author,id); }*/ public Comment modifyComment(Integer id,String author){//注意：key =\"#result.id\" 不是key =\"#result\" int i = this.commentRepository.updateComment(author, id); //再次查询操作,查询结果存入redis缓存中 return this.findById(id); } //query @Cacheable(cacheNames = \"comment\",unless = \"#result==null\")//创建缓存空间，并命名为comment,如果查询结果为null，不存入该空间 public Comment findById(Integer id){ Optional optional = this.commentRepository.findById(id); if(optional.isPresent()){ return optional.get(); } return null; }; } 实体类序列化 package com.wukongnotnull.domain; //author: 悟空非空也（B站/知乎/公众号） import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; import java.io.Serializable; @Data @NoArgsConstructor @AllArgsConstructor @Entity(name = \"b_comment\") public class Comment implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"content\") private String content; @Column(name = \"author\") private String author; @Column(name = \"article_id\") private Integer articleId; } 自定义RedisCacheManager（基于注解的缓存数据的json格式化） 基于注解的，基于api的无效，实体类可以删除ImplementSeriable 序列化 测试之前，先清空 Redis 数据库中的数据，不然会因数据库中的乱码产生报错 package com.wukongnotnull.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.cache.RedisCacheConfiguration; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializationContext; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.time.Duration; @Configuration//定义为配置类 public class RedisConfig { @Bean public RedisCacheManager cacheManager(RedisConnectionFactory redisConnectionFactory) { // 分别创建String和JSON格式序列化对象，对缓存数据key和value进行转换 RedisSerializer strSerializer = new StringRedisSerializer(); Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer<>(Object.class); // 解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 定制缓存数据序列化方式及时效 RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig() .entryTtl(Duration.ofDays(1)) .serializeKeysWith(RedisSerializationContext.SerializationPair.fromSerializer(strSerializer)) .serializeValuesWith(RedisSerializationContext.SerializationPair.fromSerializer(jacksonSeial)) .disableCachingNullValues(); return RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(config).build(); } } 使用 Redis Desktop Manager 客户端查看数据库情况 基于 API 的 Redis 缓存实现 @SpringBootApplication public class RedisSprongbootApplication { public static void main(String[] args) { SpringApplication.run(RedisSprongbootApplication.class, args); } } 实体类Comment package com.wukongnotnull.domain; //author: 悟空非空也（B站/知乎/公众号） import lombok.AllArgsConstructor; import lombok.Data; import lombok.NoArgsConstructor; import javax.persistence.*; import java.io.Serializable; @Data @NoArgsConstructor @AllArgsConstructor @Entity(name = \"b_comment\") public class Comment implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; @Column(name = \"content\") private String content; @Column(name = \"author\") private String author; @Column(name = \"article_id\") private Integer articleId; } repository:CommentRepository package com.wukongnotnull.repository; /* author: 悟空非空也（B站/知乎/公众号） */ import com.wukongnotnull.domain.Comment; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Modifying; import org.springframework.data.jpa.repository.Query; import javax.transaction.Transactional; import java.util.List; import java.util.Optional; public interface CommentRepository extends JpaRepository { @Override List findAll(); @Override Optional findById(Integer id); // 查询条件：作者不为空 List findByAuthorNotNull(); @Override long count(); @Override S saveAndFlush(S s); @Query(\"select c from b_comment c where c.articleId=?1\") List getCommentList(Integer articleId); @Query(value = \"select * from b_comment c where c.article_id=?1\",nativeQuery = true) List getCommentList2(Integer articleId); @Transactional @Modifying @Query(value = \"update b_comment set author =?1 where id =?2 \",nativeQuery = true) int updateComment(String author,Integer id); @Transactional @Modifying @Query(value = \"delete from b_comment where id = ?1\",nativeQuery = true) int deleteComment(Integer id); @Override S save(S entity); } service: ApiCommentService package com.wukongnotnull.service; import ch.qos.logback.core.util.TimeUtil; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.repository.CommentRepository; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; import org.springframework.transaction.annotation.Transactional; import java.util.Optional; import java.util.concurrent.TimeUnit; @Service @Transactional public class ApiCommentService { @Autowired private CommentRepository commentRepository; @Autowired // 引入 RedisTemplate private RedisTemplate redisTemplate; /** * 查询方法 */ public Comment findById(Integer id){ //先到缓存中查询 Comment comment = (Comment) redisTemplate.opsForValue().get(\"comment_\" + id); if(comment!=null){ //缓存中有数据 return comment; }else{//缓存中没有数据 //到数据库中进行查询 Optional byId = commentRepository.findById(id); if(byId.isPresent()){ //若是数据库中存在，将数据先存入redis Comment comment1 = byId.get(); redisTemplate.opsForValue().set(\"comment_\"+id,comment1,1, TimeUnit.DAYS); return comment1; } System.out.println(\"缓存中没有数据的情况下，数据库中也没有\"); return null; } } /** * 更新方法 */ public Comment updateComment(Comment comment){ //更新mysql数据库 int i = commentRepository.updateComment(comment.getAuthor(), comment.getId()); //更新redis缓存 redisTemplate.opsForValue().set(\"comment_\"+comment.getId(),comment); //更新后进行查询 return this.findById(comment.getId()); } /** * 删除方法 */ public void deleteComment(Integer id){ //删除 mysql 数据库中的数据 commentRepository.deleteById(id); //删除redis缓存中的数据 redisTemplate.delete(\"comment_\" + id); } } controller:ApiCommentController package com.wukongnotnull.controller; import com.wukongnotnull.domain.Comment; import com.wukongnotnull.service.ApiCommentService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PathVariable; import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RestController; @RestController @RequestMapping(\"/api\") public class ApiCommentController { @Autowired private ApiCommentService apiCommentService; //query @GetMapping(\"/query/{id}\") public Comment findById(@PathVariable(\"id\") Integer id){ return this.apiCommentService.findById(id); } //modify @GetMapping(\"/modify/{id}/{author}\") public Comment modifyBy(@PathVariable(\"id\") Integer id,@PathVariable(\"author\") String author){ Comment comment = new Comment(); comment.setId(id); comment.setAuthor(author); return this.apiCommentService.updateComment(comment); } //delete @GetMapping(\"/delete/{id}\") public void deleteById(@PathVariable(\"id\") Integer id){ this.apiCommentService.deleteComment(id); } //add } 自定义RedisTemplate(基于api的缓存数据json格式化) 痛点 缓存管理的实体类使用的jdk序列化机制，缺点：不便于可视化 缓存中的数据进行json序列化 对基于api的redis缓存有效，注解无效 package com.wukongnotnull.config; import com.fasterxml.jackson.annotation.JsonAutoDetect; import com.fasterxml.jackson.annotation.PropertyAccessor; import com.fasterxml.jackson.databind.ObjectMapper; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.data.redis.cache.RedisCacheConfiguration; import org.springframework.data.redis.cache.RedisCacheManager; import org.springframework.data.redis.connection.RedisConnectionFactory; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.data.redis.serializer.Jackson2JsonRedisSerializer; import org.springframework.data.redis.serializer.RedisSerializationContext; import org.springframework.data.redis.serializer.RedisSerializer; import org.springframework.data.redis.serializer.StringRedisSerializer; import java.time.Duration; @Configuration // 定义一个配置类 public class RedisConfig { @Bean public RedisTemplate redisTemplate(RedisConnectionFactory redisConnectionFactory) { RedisTemplate template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); // 使用JSON格式序列化对象，对缓存数据key和value进行转换 Jackson2JsonRedisSerializer jacksonSeial = new Jackson2JsonRedisSerializer(Object.class); // 解决查询缓存转换异常的问题 ObjectMapper om = new ObjectMapper(); om.setVisibility(PropertyAccessor.ALL, JsonAutoDetect.Visibility.ANY); om.enableDefaultTyping(ObjectMapper.DefaultTyping.NON_FINAL); jacksonSeial.setObjectMapper(om); // 设置RedisTemplate模板API的序列化方式为JSON template.setDefaultSerializer(jacksonSeial); return template; } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/integrate-redis.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-20 17:29:41 "},"cache-management/integrate-ehcache.html":{"url":"cache-management/integrate-ehcache.html","title":"整合 ehcache","keywords":"","body":"集成 ehcache缓存框架 EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 Spring 提供了对缓存功能的抽象：即允许绑定不同的缓存解决方案（如Ehcache），但本身不直接提供缓存功能的实现。它支持注解方式使用缓存，非常方便。 ehcache 和 redis 比较 　　ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。 　　redis是通过socket访问到缓存服务，效率比Ehcache低，比数据库要快很多，处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。 　　ehcache也有缓存共享方案，不过是通过RMI或者Jgroup多播方式进行广播缓存通知更新，缓存共享复杂，维护不方便；简单的共享可以，但是涉及到缓存恢复，大数据缓存，则不合适。 pom org.springframework.boot spring-boot-starter-cache net.sf.ehcache ehcache src/main/resources/ehcache.xml application.xml # 缓存的配置 spring: cache: ehcache: config: classpath:ehcache.xml # 开启dao层的dubug日志，打印出sql语句，便于缓存测试分析 logging: level: com.wukong.dao: debug 实体类序列化 public class User implements Serializable { } 启动类 @SpringBootApplication @EnableCaching public class App { public static void main( String[] args ) { SpringApplication.run(App.class); System.out.println( \"Hello World!\" ); } } service层设置缓存 @Service public class UserServiceImpl implements UserService { @Cacheable(value = \"users\", key = \"#username\") public User getUserByUsername(String username) { } @Cacheable(value = \"users\",key = \"#id\") public User getUserById(Integer id) { } // 添加用户，不需要添加到缓存容器中 public void addUser(User user) { } // 修改用户，返回类型不能是void， // 参数是对象是，使用 #user.id 作为关键词 // @CachePut 作用：修改数据库的同时，同步修改缓存容器 // 当然也可以直接使用@CacheEvict ,修改数据库同时删除缓存容器中该数据 @CachePut(value = \"users\", key = \"#user.id\") public User modifyUser(User user) { return user; } // @CacheEvict 作用： 删除数据库的同时，删除缓存容器 @CacheEvict(value = \"users\", allEntries = true) public void deleteUser(Integer id) { } //参数是封装对象时，可以使用多个key ，写法如下 @Cacheable(value = \"users\" ,key = \"#userParams.pageNum+'-'+#userParams.pageSize+'-'+#userParams.username\") public PageInfo getUserPageList(UserParams userParams) { } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/cache-management/integrate-ehcache.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-03 11:11:38 "},"security-management/security-management.html":{"url":"security-management/security-management.html","title":"安全管理","keywords":"","body":"SpringSecurity介绍 Spring Security 快速入门 pom.xml org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web 直接url访问 默认显示 登录界面，该界面是由spring security提供的 用户名 user 密码 启动项目时候，在控制台随机生成 Mvc Security 安全配置介绍 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/security-management/security-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-26 09:16:44 "},"security-management/authentication.html":{"url":"security-management/authentication.html","title":"Security 身份认证","keywords":"","body":"内存身份认证 自定义用户名和密码，该方法适用于测试环境，临时使用 package com.wukongnotnull.config; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; //author: 悟空非空也（B站/知乎/公众号） @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //设置密码编码器 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); // 内存身份认证，模拟测试用户 InMemoryUserDetailsManagerConfigurer builder = auth.inMemoryAuthentication().passwordEncoder(bCryptPasswordEncoder); builder.withUser(\"wukong\").password(bCryptPasswordEncoder.encode(\"wukong\")).roles(\"common\"); builder.withUser(\"admin\").password(bCryptPasswordEncoder.encode(\"admin\")).roles(\"vip\"); } } JDBC 身份认证 sql 脚本 #use database USE springbootdata; #create t_customer 并插入相关数据 DROP TABLE IF EXISTS `t_customer`; CREATE TABLE t_customer ( `id` INT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY, username VARCHAR(200), `password` VARCHAR(200), `valid` TINYINT(1) NOT NULL DEFAULT '1' ); INSERT INTO t_customer VALUES( '1','wukong','wukong','1' ),( '2','admin','admin','1' ); #创建表 t_authority 并插入数据 DROP TABLE IF EXISTS `t_authority`; CREATE TABLE `t_authority`( id INT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY, authority VARCHAR(20) ); INSERT INTO `t_authority` VALUES( 1,'ROLE_common' ),(2,'ROLE_vip'); #创建中间表 t_customer_authority，并插入数据 DROP TABLE IF EXISTS `t_customer_authority`; CREATE TABLE `t_customer_authority`( id INT(20) NOT NULL AUTO_INCREMENT PRIMARY KEY, customer_id INT(20), authority_id INT(20) ); INSERT INTO `t_customer_authority` VALUES( '1','1','1' ),( '2','2','2' ); 配置mysql连接和redis连接 # MySQL spring.datasource.url=jdbc:mysql://localhost:3306/springbootdata?serverTimezone=UTC spring.datasource.username=root spring.datasource.password=root spring.thymeleaf.cache=false 添加依赖 org.springframework.boot spring-boot-starter-jdbc mysql mysql-connector-java 编写安全配置类 package com.wukong.config; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.authentication.configurers.provisioning.InMemoryUserDetailsManagerConfigurer; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; import javax.sql.DataSource; @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private DataSource dataSource; //重写 configure方法 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //设置密码编码器 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); //使用jdbc进行身份认证 String userSQL =\"select username,password,valid from t_customer \" + \"where username = ?\"; String authoritySQL=\"select c.username,a.authority from t_customer c,t_authority a,\"+ \"t_customer_authority ca where ca.customer_id=c.id \" + \"and ca.authority_id=a.id and c.username =?\"; auth.jdbcAuthentication().passwordEncoder(bCryptPasswordEncoder) .dataSource(dataSource) .usersByUsernameQuery(userSQL) .authoritiesByUsernameQuery(authoritySQL); } } 登录测试 1 对密码进行编码加密 @Test void contextLoads() { //设置密码编码器 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); String wukong = bCryptPasswordEncoder.encode(\"wukong\"); String admin = bCryptPasswordEncoder.encode(\"admin\"); System.out.println(\"wukong = \" + wukong); System.out.println(\"admin = \" + admin); System.out.println(\"是否编码成功？---> \" + bCryptPasswordEncoder.matches(\"wukong\", wukong)); } 2 生成的密码保存到数据库中 UserDetailService 身份认证 pom.xml org.springframework.boot spring-boot-starter-data-redis org.springframework.boot spring-boot-starter-data-jpa mysql mysql-connector-java runtime org.springframework.boot spring-boot-starter-security org.springframework.boot spring-boot-starter-web domain: Authority package com.wukongnotnull.domain; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import java.io.Serializable; @Entity(name = \"t_authority\") public class Authority implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String authority; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getAuthority() { return authority; } public void setAuthority(String authority) { this.authority = authority; } @Override public String toString() { return \"Authority{\" + \"id=\" + id + \", authority='\" + authority + '\\'' + '}'; } } Customer package com.wukongnotnull.domain; import javax.persistence.Entity; import javax.persistence.GeneratedValue; import javax.persistence.GenerationType; import javax.persistence.Id; import java.io.Serializable; @Entity(name = \"t_customer\") public class Customer implements Serializable { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String username; private String password; private Integer valid; public Integer getValid() { return valid; } public void setValid(Integer valid) { this.valid = valid; } public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } } repository: AuthorityRepository package com.wukongnotnull.repository; import com.wukong.domain.Authority; import org.springframework.data.jpa.repository.JpaRepository; import org.springframework.data.jpa.repository.Query; import java.util.List; public interface AuthorityRepository extends JpaRepository { @Query(value = \"select a.* from t_customer c,t_authority a,t_customer_authority ca where ca.customer_id=c.id and ca.authority_id=a.id and c.username =?1\",nativeQuery = true) public List findAuthoritiesByUsername(String username); } CustomerRepository package com.wukong.repository; import com.wukong.domain.Customer; import org.springframework.data.jpa.repository.JpaRepository; public interface CustomerRepository extends JpaRepository { Customer findByUsername(String username); } service: CustomerService package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.domain.Customer; public interface CustomerService { // 根据用户名查询用户信息 Customer findByUsername(String username); } AuthorityService package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.domain.Authority; import java.util.List; public interface AuthorityService { public List findAuthoritiesByUsername(String username); } CustomerServiceImpl package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.dao.CustomerRepository; import com.wukongnotnull.domain.Customer; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; @Service public class CustomerServiceImpl implements CustomerService{ @Autowired private CustomerRepository customerRepository; @Autowired private RedisTemplate redisTemplate; // 整合redis缓存,根据用户名查询用户信息 public Customer findByUsername(String username){ Customer customer=null; Object o = redisTemplate.opsForValue().get(\"customer_\"+username); if(o!=null){ customer=(Customer)o; }else { customer = customerRepository.findByUsername(username); if(customer!=null){ redisTemplate.opsForValue().set(\"customer_\"+username,customer); } } return customer; } } AuthorityServiceImpl package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.dao.AuthorityRepository; import com.wukongnotnull.domain.Authority; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.data.redis.core.RedisTemplate; import org.springframework.stereotype.Service; import java.util.List; @Service public class AuthorityServiceImpl implements AuthorityService{ @Autowired private AuthorityRepository authorityRepository; @Autowired private RedisTemplate redisTemplate; // 整合 redis 缓存，根据唯一用户名查询权限列表 public List findAuthoritiesByUsername(String username){ List authorities=null; Object o = redisTemplate.opsForValue().get(\"authorities_\" + username); if(o!=null){ authorities=(List) o; }else { authorities=authorityRepository.findAuthoritiesByUsername(username); if(authorities.size()>0){ redisTemplate.opsForValue().set(\"authorities_\"+username,authorities); } } return authorities; } } UserDetailsServiceImpl package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.domain.Authority; import com.wukongnotnull.domain.Customer; import lombok.Data; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.User; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import org.springframework.stereotype.Service; import java.util.List; import java.util.stream.Collectors; @Service public class UserDetailsServiceImpl implements UserDetailsService { @Autowired private CustomerService customerService; @Autowired private AuthorityService authorityService; /** * Locates the user based on the username. In the actual implementation, the search * may possibly be case sensitive, or case insensitive depending on how the * implementation instance is configured. In this case, the UserDetails * object that comes back may have a username that is of a different case than what * was actually requested.. * * @param username the username identifying the user whose data is required. * @return a fully populated user record (never null) * @throws UsernameNotFoundException if the user could not be found or the user has no * GrantedAuthority */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { //通过业务方法获取用户及权限信息 Customer customer = customerService.findByUsername(username); List authorities = authorityService.findAuthoritiesByUsername(username); // 对用户权限进行封装 List authorityList = authorities.stream(). map(authority -> new SimpleGrantedAuthority(authority.getAuthority())) .collect(Collectors.toList()); // 返回封装的UserDetails用户详情类 if(customer!=null){ // 同名用户存在，那么密码是否一致呢？ UserDetails userDetails= new User(customer.getUsername(),customer.getPassword(),authorityList); return userDetails; } else { // 如果查询的用户不存在（用户名不存在），必须抛出此异常 throw new UsernameNotFoundException(\"当前用户不存在！\"); } } } SecurityConfig 使用Springboot集合Springsecurity的时候，报了一个java.lang.IllegalArgumentException: There is no PasswordEncoder 原因 security 1.5.0以上的版本，增加多种的加密方式，为了增加安全，要求将密码通过加密算法处理过后才存入数据库。 客户端传递过来的明文密码需要加密后，和数据库中的暗文进行对比，实现身份验证。 package com.wukongnotnull.config; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder; //author: 悟空非空也（B站/知乎/公众号） @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserDetailsService userDetailsService; @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { //设置密码编码器 BCryptPasswordEncoder bCryptPasswordEncoder = new BCryptPasswordEncoder(); //使用 UserDetailsService 进行身份认证时，对明文密码进行加密 auth.userDetailsService(userDetailsService).passwordEncoder(bCryptPasswordEncoder); } } 登录测试 用户名 密码 wukong wukong admin admin 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/security-management/authentication.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-28 15:41:08 "},"security-management/authorization.html":{"url":"security-management/authorization.html","title":"Security 权限认证","keywords":"","body":"悟空编号 学前素材准备 前端资源（html css js image 等等） 链接：https://share.weiyun.com/QD9u6jjX 密码：wukong 自定义用户访问控制 访问首页授权 index.html 访问静态资源（图片和样式）授权 @Override protected void configure(HttpSecurity http) throws Exception { // 自定义用户授权管理 http.authorizeRequests() // 所有人都可以访问 .antMatchers(\"/\").permitAll() // 需要对static文件夹下静态资源（图片和样式）进行统一放行 .antMatchers(\"/login/**\").permitAll() // 访问如下请求需要 角色（权限）是 common 或者 vip .antMatchers(\"/detail/common/**\").hasAnyRole(\"common\",\"vip\") .antMatchers(\"/detail/vip/**\").hasRole(\"vip\") // 任何请求访问都需要先进行身份认证 .anyRequest().authenticated(); } Spring Security 中的 hasRole 和 hasAuthority 有区别吗？ https://cloud.tencent.com/developer/article/1703187 hasRole() public ExpressionInterceptUrlRegistry hasRole(String role) { return access(ExpressionUrlAuthorizationConfigurer.hasRole(role)); } private static String hasRole(String role) { Assert.notNull(role, \"role cannot be null\"); if (role.startsWith(\"ROLE_\")) { throw new IllegalArgumentException( \"role should not start with 'ROLE_' since it is automatically inserted. Got '\" + role + \"'\"); } return \"hasRole('ROLE_\" + role + \"')\"; } 自定义用户登录页面 用户登录界面 请登录 用户名或密码错误，请重新登录！ 记住我 登录 Copyright© 2050-3030 package com.wukongnotnull.controller; import org.springframework.security.core.Authentication; import org.springframework.security.core.context.SecurityContext; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.ResponseBody; //author: 悟空非空也（B站/知乎/公众号） @Controller public class LoginController { @GetMapping(\"/userLogin\") //路径要和 提交登录表单的url 一致 public String index(){ return \"login/login\"; } } package com.wukongnotnull.config; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import javax.sql.DataSource; //author: 悟空非空也（B站/知乎/公众号） @EnableWebSecurity public class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { // 自定义用户登录控制 // 技巧： 获得登录页和处理登录信息的 url 都是 /userLogin , post 请求进入如下方法 http.authorizeRequests().and() // 开启登录功能 .formLogin() // 访问登录页面（自定义登录路径） .loginPage(\"/userLogin\").permitAll() // 指定登录处理的 url ，对应action的值 .loginProcessingUrl(\"/userLogin\") .usernameParameter(\"name\") .passwordParameter(\"pwd\") // 登录成功后，访问首页 / .defaultSuccessUrl(\"/\") // 登录失败后，访问 /userLogin?error .failureUrl(\"/userLogin?error\"); } } 自定义用户退出 @Override protected void configure(HttpSecurity http) throws Exception { // 退出 http // 开启退出功能 .logout() // 访问 /logout 执行退出功能 .logoutUrl(\"/logout\") // 退出成功，访问首页 / .logoutSuccessUrl(\"/\"); } 登录用户信息获取 /** * 通过 Security 提供的 SecurityContextHolder 获取登录用户信息 * @return String */ @GetMapping(\"/userInfo\") @ResponseBody public String getUser(){ // 获取应用上下文 SecurityContext context = SecurityContextHolder.getContext(); // 获取用户相关信息 Authentication authentication = context.getAuthentication(); UserDetails userDetails = (UserDetails)authentication.getPrincipal(); System.out.println(\"username: \"+userDetails.getUsername()); return \"登录的用户名为： \" + userDetails.getUsername(); } 记得我功能 记住我 USE springbootdata; # 来源于 JdbcTokenRepositoryImpl create table persistent_logins (username varchar(64) not null, series varchar(64) primary key, token varchar(64) not null, last_used timestamp not null); org.springframework.boot spring-boot-starter-jdbc // 使用jdbc 技术访问数据库 @Autowired private DataSource dataSource; /** * 持久化Token存储 * @return */ @Bean public JdbcTokenRepositoryImpl tokenRepository(){ JdbcTokenRepositoryImpl jr=new JdbcTokenRepositoryImpl(); jr.setDataSource(dataSource); return jr; } @Override protected void configure(HttpSecurity http) throws Exception { // 记住我 http.rememberMe() .rememberMeParameter(\"rememberMe\") .tokenValiditySeconds(60*60*24*7) .tokenRepository(this.tokenRepository()); } CSRF防护功能 跨站伪造用户，获得真实用户的 session 信息，伪造成真实用户，进行非法操作。 form 表单使用 csrf 防护 修改用户 用户名: 修改用户名 package com.wukongnotnull.controller; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.PostMapping; import org.springframework.web.bind.annotation.RequestParam; import org.springframework.web.bind.annotation.ResponseBody; import javax.servlet.http.HttpServletRequest; //author: 悟空非空也（B站/知乎/公众号） @Controller public class CSRFController { @GetMapping(\"/updateUser\") public String updateUser(){ return \"csrf/csrfTest\"; } @ResponseBody @PostMapping(\"/updateUser\") public String updateUser(@RequestParam(\"username\") String username, HttpServletRequest request ){ System.out.println(\"request = \" + request); String csrf_token=request.getParameter(\"_csrf\"); System.out.println(\"csrf_token = \" + csrf_token); System.out.println(\"username = \" + username); return \"success\"; } } ajax 使用 csrf 防护 //针对ajax数据修改的CSRF Token配置 $(function () { var token = $(\"meta[name='_csrf']\").attr(\"content\"); var headerName = $(\"meta[name='_csrf_header']\").attr(\"content\"); $(document).ajaxSend(function(e, xhr, options) { xhr.setRequestHeader(headerName, token); }); }); Security 管理前端页面内容呈现 不同权限，页面内容针对性呈现不同的内容 应用场景： 动态菜单的实现 org.thymeleaf.extras thymeleaf-extras-springsecurity5 (1)sec:authorize=\"isAuthenticated()\" 判断用户是否已经登陆认证，引号内的参数必须是isAuthenticated()。 (2)sec:authentication=“name” 获得当前用户的用户名，引号内的参数必须是name。 (3)sec:authorize=“hasRole(‘role’)” 判断当前用户是否拥有指定的权限。引号内的参数为权限的名称。 (4)sec:authentication=\"principal.authorities\" 获得当前用户的全部角色，引号内的参数必须是principal.authorities。 index.html 新浪新闻平台 欢迎新浪新闻首页 游客您好，如果想查看会员新闻请登录 用户: 您的权限：，您有权观看以下内容 游客 - 新闻专栏 新闻1：悟空非空也带你学习 Java 新闻2：悟空非空也带你学习 Python 新闻3：悟空非空也带你学习 C++ --> 普通会员 - 新闻专栏 普通会员新闻：1 普通会员新闻：2 --> VIP会员 - 专享专栏 vip会员新闻：1 vip会员新闻：2 源码归档 归档链接 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/security-management/authorization.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-01 17:54:11 "},"shiro/shiro.html":{"url":"shiro/shiro.html","title":"shiro 安全管理","keywords":"","body":"Shiro 什么是 Shiro？ 官网：http://shiro.apache.org/ 是一款主流的 Java 安全框架，不依赖任何容器，可以运行在 Java SE 和 Java EE 项目中，它的主要作用是对访问系统的用户进行身份认证、授权、会话管理、加密等操作。 Shiro 就是用来解决安全管理的系统化框架。 Shiro 核心组件 用户、角色、权限 三者的关系是什么？ 给用户赋予角色 ,会给角色赋予权限。 UsernamePasswordToken Shiro 用来封装用户登录信息，使用用户的登录信息来创建令牌 Token。 SecurityManager Shiro 的核心部分，负责安全认证和授权。 Suject Shiro 的一个抽象概念，包含了用户信息。 Realm 开发者自定义的模块，根据项目的需求，验证和授权的逻辑全部写在 Realm 中。 AuthenticationInfo 用户的角色信息集合，认证时使用。 AuthorzationInfo 角色的权限信息集合，授权时使用。 DefaultWebSecurityManager 安全管理器，自定义的 Realm 需要注入到 DefaultWebSecurityManager 进行管理才能生效。 ShiroFilterFactoryBean 过滤器工厂，Shiro 的基本运行机制是开发者定制规则，Shiro 去执行，具体执行操作由 ShiroFilterFactoryBean 创建的每个 Filter 对象来完成。 Shiro 的运行机制如下图所示。 Spring Boot 整合 Shiro 1、创建 Spring Boot 应用，集成 Shiro 及相关组件，pom.xml org.springframework.boot spring-boot-starter-thymeleaf org.springframework.boot spring-boot-starter-web org.projectlombok lombok true org.apache.shiro shiro-spring 1.5.3 mysql mysql-connector-java com.baomidou mybatis-plus-boot-starter 3.3.1.tmp 2、自定义 Shiro 过滤器 public class AccoutRealm extends AuthorizingRealm { @Autowired private AccountService accountService; /** * 授权 */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { //获取当前登录的用户信息 Subject subject = SecurityUtils.getSubject(); Account account = (Account) subject.getPrincipal(); //设置角色，确定用户具备哪些角色 Set roles = new HashSet<>(); roles.add(account.getRole()); SimpleAuthorizationInfo info = new SimpleAuthorizationInfo(roles); //设置权限 info.addStringPermission(account.getPerms()); return info; } /** * 身份认证(登录验证) */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { UsernamePasswordToken token = (UsernamePasswordToken) authenticationToken; Account account = accountService.findByUsername(token.getUsername()); if(account != null){ // 若是 密码不一致，shiro 抛出异常，表示密码不一致 return new SimpleAuthenticationInfo(account,account.getPassword(),getName()); } return null; //shiro 抛出异常，表示用户名不存在 } } 3、配置类 @Configuration public class ShiroConfig { @Bean public AccoutRealm accoutRealm(){ return new AccoutRealm(); } @Bean public DefaultWebSecurityManager securityManager(@Qualifier(\"accoutRealm\") AccoutRealm accoutRealm){ DefaultWebSecurityManager manager = new DefaultWebSecurityManager(); manager.setRealm(accoutRealm); return manager; } @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager securityManager){ ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(securityManager); return factoryBean; } } controller @Controller public class AccountController { @GetMapping(\"/{url}\") public String redirect(@PathVariable(\"url\") String url){ return url; } @PostMapping(\"/login\") public String login(String username, String password, Model model){ Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username,password); try { subject.login(token); Account account = (Account) subject.getPrincipal(); subject.getSession().setAttribute(\"account\",account); return \"index\"; } catch (UnknownAccountException e) { e.printStackTrace(); model.addAttribute(\"msg\",\"用户名错误！\"); return \"login\"; } catch (IncorrectCredentialsException e){ model.addAttribute(\"msg\",\"密码错误！\"); e.printStackTrace(); return \"login\"; } } @GetMapping(\"/unauth\") @ResponseBody public String unauth(){ return \"未授权，无法访问！\"; } @GetMapping(\"/logout\") public String logout(){ Subject subject = SecurityUtils.getSubject(); subject.logout(); return \"login\"; } } 编写认证和授权规则： 认证过滤器 anon：无需认证。 authc：必须认证。 authcBasic：需要通过 HTTPBasic 认证。 user：不一定通过认证，只要曾经被 Shiro 记录即可，比如：记住我。 授权过滤器 perms：必须拥有某个权限才能访问。 role：必须拥有某个角色才能访问。 port：请求的端口必须是指定值才可以。 rest：请求必须基于 RESTful，POST、PUT、GET、DELETE。 ssl：必须是安全的 URL 请求，协议 HTTPS。 创建 3 个页面，main.html、manage.html、administrator.html 访问权限如下： 1、必须登录才能访问 main.html 2、当前用户必须拥有 manage 授权才能访问 manage.html 3、当前用户必须拥有 administrator 角色才能访问 administrator.html 访问控制 不同请求需要满足设置好的权限，才能访问成功。 可以将不同的请求路径，设置不同的权限。只有符合指定的权限，才能正常访问。 import at.pollux.thymeleaf.shiro.dialect.ShiroDialect; import org.apache.shiro.spring.web.ShiroFilterFactoryBean; import org.apache.shiro.web.mgt.DefaultWebSecurityManager; import org.springframework.beans.factory.annotation.Qualifier; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import java.util.Hashtable; import java.util.Map; @Configuration public class ShiroConfig { @Bean public ShiroFilterFactoryBean shiroFilterFactoryBean(@Qualifier(\"securityManager\") DefaultWebSecurityManager securityManager){ ShiroFilterFactoryBean factoryBean = new ShiroFilterFactoryBean(); factoryBean.setSecurityManager(securityManager); //设置登录页面 factoryBean.setLoginUrl(\"/login\"); //权限设置 Map map = new Hashtable<>(); map.put(\"/main\",\"authc\"); map.put(\"/manage\",\"perms[manage]\"); map.put(\"/administrator\",\"roles[administrator]\"); factoryBean.setFilterChainDefinitionMap(map); //设置未授权页面 factoryBean.setUnauthorizedUrl(\"/unauth\"); return factoryBean; } @Bean // @Qualifier(\"同下面的方法名\") public DefaultWebSecurityManager securityManager(@Qualifier(\"accoutRealm\") AccoutRealm accoutRealm){ DefaultWebSecurityManager manager = new DefaultWebSecurityManager(); manager.setRealm(accoutRealm); return manager; } @Bean public AccoutRealm accoutRealm(){ return new AccoutRealm(); } } controller @Controller public class AccountController { @GetMapping(\"/{url}\") public String redirect(@PathVariable(\"url\") String url){ return url; } @PostMapping(\"/login\") public String login(String username, String password, Model model){ Subject subject = SecurityUtils.getSubject(); UsernamePasswordToken token = new UsernamePasswordToken(username,password); try { subject.login(token); //如果登录身份验证成功，执行下面代码 Account account = (Account) subject.getPrincipal(); subject.getSession().setAttribute(\"account\",account); return \"index\"; } catch (UnknownAccountException e) { e.printStackTrace(); model.addAttribute(\"msg\",\"用户名错误！\"); return \"login\"; } catch (IncorrectCredentialsException e){ model.addAttribute(\"msg\",\"密码错误！\"); e.printStackTrace(); return \"login\"; } } @GetMapping(\"/unauth\") @ResponseBody public String unauth(){ return \"未授权，无法访问！\"; } @GetMapping(\"/logout\") public String logout(){ Subject subject = SecurityUtils.getSubject(); subject.logout(); return \"login\"; } } Shiro 整合 Thymeleaf 1、pom.xml 引入依赖 com.github.theborakompanioni thymeleaf-extras-shiro 2.0.0 2、配置类添加 ShiroDialect @Bean public ShiroDialect shiroDialect(){ return new ShiroDialect(); } 3、index.html Title index 退出 main manage administrator 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/shiro/shiro.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-02 09:35:01 "},"message-service/message-service.html":{"url":"message-service/message-service.html","title":"消息服务","keywords":"","body":"为什么要使用消息服务 在多数应用尤其是分布式系统中，消息服务是不可或缺的重要部分，它使用起来比较简单，同时解决了不少难题，例如异步处理、应用解耦、流量削锋、分布式事务管理等，使用消息服务可以实现一个高性能、高可用、高扩展的系统。 异步处理 应用解耦 流量削峰 分布式事务 1.订单支付成功后，写入消息表 2.定时扫描消息表消息写入到消息队列中 3.库存系统会立即读取到消息队列中的消息进行库存更新，同时添加消息处理状态 4.库存系统向消息队列中写入库存处理结果 5.订单系统会立即读取到消息队列中的库存处理状态。直接删除消息表数据，并写入到历史消息表 常用消息中间件介绍 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/message-service/message-service.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-20 17:41:58 "},"task-management/task-management.html":{"url":"task-management/task-management.html","title":"任务管理","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/task-management.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-11 17:11:56 "},"task-management/asynch-call.html":{"url":"task-management/asynch-call.html","title":"异步调用","keywords":"","body":"无返回值异步任务调用 应用场景： 发送注册验证码 org.springframework.boot spring-boot-starter-web 1-application.java package com.wukongnotnull; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.scheduling.annotation.EnableAsync; @EnableAsync @SpringBootApplication public class SbTaskApplication { public static void main(String[] args) { SpringApplication.run(SbTaskApplication.class, args); } } 2-service package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） public interface MyAsyncService { public void sendSms(); } package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.scheduling.annotation.Async; import org.springframework.stereotype.Service; @Service public class MyAsyncServiceImpl implements MyAsyncService{ @Async public void sendSms(){ long startTime = System.currentTimeMillis(); System.out.println(\"service--->sendSms-->发送短信进行中。。。\"); try { Thread.sleep(5000); }catch (Exception e){ e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\"service 共耗时\"+(endTime-startTime)); } } 3-controller package com.wukongnotnull.controller; //author: 悟空非空也（B站/知乎/公众号） import com.wukongnotnull.service.MyAsyncService; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class MyAsyncController { @Autowired private MyAsyncService myAsyncService; @GetMapping(\"/sendsms\") public String sendSms(){ System.out.println(\"controller-->sendSms--> 开始执行\"); myAsyncService.sendSms(); System.out.println(\"controller-->sendSms--> 执行结束\"); return \"短信验证码已发送，请稍后查收\"; } } 4-test 有返回值异步任务调用 2个方法 processA() 和 processB() 同时执行，不是先后执行 1-sevice @Service public class MyAsyncService { @Async public Future processA(){ System.out.println(\"MyAsyncService-->start processA\"); long startTime = System.currentTimeMillis(); try { Thread.sleep(4000); } catch (InterruptedException e) { e.printStackTrace(); } int count=123; long endTime = System.currentTimeMillis(); System.out.println(\"MyAsyncService-->processA end ,total time cost \"+(endTime-startTime)); return new AsyncResult(count); } @Async public Future processB(){ System.out.println(\"MyAsyncService-->start processB\"); long startTime = System.currentTimeMillis(); try { Thread.sleep(5000); } catch (InterruptedException e) { e.printStackTrace(); } int count=321; long endTime = System.currentTimeMillis(); System.out.println(\"MyAsyncService-->processB end ,total time cost \"+(endTime-startTime)); return new AsyncResult(count); } 2-controller @RequestMapping(\"/statistics\") public String statistics(){ long startTime = System.currentTimeMillis(); Future processA = myAsyncService.processA(); Future processB = myAsyncService.processB(); try { Integer totalCount=processA.get()+processB.get(); System.out.println(\"totalCount is\"+totalCount); } catch (Exception e) { e.printStackTrace(); } long endTime = System.currentTimeMillis(); System.out.println(\"AsyncController-->statistics-->total time is\"+(endTime-startTime)); return \"success\"; } 3-test 所谓异步就是2个方法同时执行 上述异步方法是有返回值的，这样主流程在执行异步方法时会有短暂阻塞，需要等待并获取异步方法的返回结果，而调用的两个异步方法会作为两个子线程并行执行，直到异步方法执行完成并返回结果，这样主流程会在最后一个异步方法返回结果后跳出阻塞状态。 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/asynch-call.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-24 10:20:37 "},"task-management/timed-task.html":{"url":"task-management/timed-task.html","title":"定时任务","keywords":"","body":"定时任务介绍 @Scheduled注解 https://www.jianshu.com/p/1defb0f22ed1 定时任务实现 新建定时业务处理类 ScheduledTaskService 该类中编写定时任务处理方法使用 @Scheduled 注解声明了三个定时任务方法， 定制的执行规则基本相同，都是每隔1分钟重复执行一次定时任务 在使用 fixedDelay 属性的方法 scheduledTaskAfterSleep() 中，使用 Thread.sleep(10000 )模拟该定时任务处理耗时为10秒钟。 启动类 @EnableScheduling @SpringBootApplication public class SbTaskApplication { public static void main(String[] args) { SpringApplication.run(SbTaskApplication.class, args); } } service @Service public class ScheduledTaskService { private static final SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); private Integer count1 = 1; private Integer count2 = 1; private Integer count3 = 1; //每隔1分钟，执行一次 @Scheduled(fixedRate = 60000) public void scheduledTaskImmediately() { System.out.println(String.format(\"fixedRate第%s次执行，当前时间为：%s\", count1++, dateFormat.format(new Date()))); } //每隔1分10秒（1分钟定时+业务处理时间10秒），执行一次 @Scheduled(fixedDelay = 60000) public void scheduledTaskAfterSleep() throws InterruptedException { System.out.println(String.format(\"fixedDelay第%s次执行，当前时间为：%s\", count2++, dateFormat.format(new Date()))); Thread.sleep(10000);//模拟业务处理时间 } //整秒输出 @Scheduled(cron = \"0 * * * * *\") public void scheduledTaskCron(){ System.out.println(String.format(\"cron第%s次执行，当前时间为：%s\", count3++, dateFormat.format(new Date()))); } } 启动启动类测试 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/timed-task.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-24 21:11:24 "},"task-management/send-email.html":{"url":"task-management/send-email.html","title":"发送邮件","keywords":"","body":"发送纯文本邮件 pom.xml org.springframework.boot spring-boot-starter-mail application.yml spring.mail.host=smtp.qq.com spring.mail.port=587 spring.mail.username=1390128154@qq.com spring.mail.password=wvthphmybrqmhidf spring.mail.default-encoding=UTF-8 spring.mail.properties.mail.smtp.connectiontimeout=5000 spring.mail.properties.mail.smtp.timeout=3000 spring.mail.properties.mail.smtp.writetimeout=5000 service package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.MailException; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSenderImpl; import org.springframework.mail.javamail.MimeMessageHelper; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import java.io.File; @Service public class SendMailService { @Autowired private JavaMailSenderImpl mailSender; @Value(\"${spring.mail.username}\") private String from; /** * 发送纯文本邮件 * @param to 收件人地址 * @param subject 邮件标题 * @param text 邮件内容 */ public void sendSimpleEmail(String to,String subject,String text){ // 定制纯文本邮件信息SimpleMailMessage SimpleMailMessage message = new SimpleMailMessage(); message.setFrom(from); message.setTo(to); message.setSubject(subject); message.setText(text); try { // 发送邮件 mailSender.send(message); System.out.println(\"纯文本邮件发送成功\"); } catch (MailException e) { System.out.println(\"纯文本邮件发送失败 \"+e.getMessage()); e.printStackTrace(); } } } test package com.wukongnotnull.service; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.Context; //author: 悟空非空也（B站/知乎/公众号） @SpringBootTest class SendMailServiceTest { @Autowired private SendMailService sendMailService ; @Autowired private TemplateEngine templateEngine; FastStringWriter fastStringWriter; @Test void sendSimpleEmail() { sendMailService.sendSimpleEmail(\"1390128154@qq.com\",\"标题123\",\"内容123\"); } } 发送带附件和图片的文件 service package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.MailException; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSenderImpl; import org.springframework.mail.javamail.MimeMessageHelper; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import java.io.File; @Service public class SendMailService { @Autowired private JavaMailSenderImpl mailSender; @Value(\"${spring.mail.username}\") private String from; /** * 发送复杂邮件（包括静态资源和附件） * * @param to 收件人地址 * @param subject 邮件标题 * @param text 邮件内容 * @param filePath 附件地址 * @param rscId 静态资源唯一标识 * @param rscPath 静态资源地址 */ public void sendComplexEmail( String to, String subject, String text, String filePath, String rscId, String rscPath){ // 定制复杂邮件信息 MimeMessage MimeMessage message = mailSender.createMimeMessage(); try { // 使用 MimeMessageHelper 帮助类，并设置 multipart 多部件使用为 true MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(text, true); // 设置邮件静态资源 FileSystemResource res = new FileSystemResource(new File(rscPath)); helper.addInline(rscId, res); // 设置邮件附件 FileSystemResource file = new FileSystemResource(new File(filePath)); String fileName = filePath.substring(filePath.lastIndexOf(File.separator)); helper.addAttachment(fileName, file); // 发送邮件 mailSender.send(message); System.out.println(\"复杂邮件发送成功\"); } catch (MessagingException e) { System.out.println(\"复杂邮件发送失败 \"+e.getMessage()); e.printStackTrace(); } } } test package com.wukongnotnull.service; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.Context; //author: 悟空非空也（B站/知乎/公众号） @SpringBootTest class SendMailServiceTest { @Autowired private SendMailService sendMailService ; @Autowired private TemplateEngine templateEngine; FastStringWriter fastStringWriter; @Test void sendComplexEmail() { StringBuffer text = new StringBuffer(); String rscId = \"img_2616\"; text.append(\"\"); text.append(\"这是邮件正文\"); text.append(\"\"); text.append(\"\"); sendMailService.sendComplexEmail(\"1390128154@qq.com\", \"带附件的邮件标题\", text.toString(), \"/Users/mac/Downloads/信1901班级人员名单.xlsx\", rscId, \"/Users/mac/Downloads/IMG_2616.JPG\"); } } 发送模板邮件 pom.xml org.springframework.boot spring-boot-starter-thymeleaf emailTemplate.html email 用户您好，你的验证码是 service package com.wukongnotnull.service; //author: 悟空非空也（B站/知乎/公众号） import org.springframework.stereotype.Service; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.beans.factory.annotation.Value; import org.springframework.core.io.FileSystemResource; import org.springframework.mail.MailException; import org.springframework.mail.SimpleMailMessage; import org.springframework.mail.javamail.JavaMailSenderImpl; import org.springframework.mail.javamail.MimeMessageHelper; import javax.mail.MessagingException; import javax.mail.internet.MimeMessage; import java.io.File; @Service public class SendMailService { @Autowired private JavaMailSenderImpl mailSender; @Value(\"${spring.mail.username}\") private String from; /** * 发送模板邮件 * @param to 收件人地址 * @param subject 邮件标题 * @param content 邮件内容 */ public void sendTemplateEmail(String to, String subject, String content) { MimeMessage message = mailSender.createMimeMessage(); try { // 使用MimeMessageHelper帮助类，并设置multipart多部件使用为true MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setFrom(from); helper.setTo(to); helper.setSubject(subject); helper.setText(content, true); // 发送邮件 mailSender.send(message); System.out.println(\"模板邮件发送成功\"); } catch (MessagingException e) { System.out.println(\"模板邮件发送失败 \"+e.getMessage()); e.printStackTrace(); } } } test import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.Context; 两个类无法识别 ，后续解决 package com.wukongnotnull.service; import org.junit.jupiter.api.Test; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.boot.test.context.SpringBootTest; import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.Context; //author: 悟空非空也（B站/知乎/公众号） @SpringBootTest class SendMailServiceTest { @Autowired private SendMailService sendMailService ; @Autowired private TemplateEngine templateEngine; @Test void sendTemplateEmail() { String to=\"1390128154@qq.com\"; String subject=\"【模板邮件】标题\"; // 使用模板邮件定制邮件正文内容 Context context = new Context(); context.setVariable(\"username\", \"悟空非空也\"); context.setVariable(\"code\", \"456123\"); // 使用TemplateEngine设置要处理的模板页面 String emailContent = templateEngine.process(\"emailTemplate\", context); // 发送模板邮件 sendMailService.sendTemplateEmail(to,subject,emailContent); } } 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/send-email.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-24 21:05:47 "},"task-management/integrate-quartz.html":{"url":"task-management/integrate-quartz.html","title":"整合 Quartz","keywords":"","body":"作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/task-management/integrate-quartz.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-06 10:20:23 "},"actuator-intergrate/actuator-intergrate.html":{"url":"actuator-intergrate/actuator-intergrate.html","title":"指标监控","keywords":"","body":"引入依赖 org.springframework.boot spring-boot-starter-actuator 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/actuator-intergrate/actuator-intergrate.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-08-05 23:37:17 "},"integrated-project/integrated-project.html":{"url":"integrated-project/integrated-project.html","title":"综合项目","keywords":"","body":"Spring Boot 综合项目实战 项目概述 系统开发及运行环境 Window 10 jdk 1.8 Maven 3.6 Mysql 8.x redis Idea 项目结构 前端素材 10.5系统环境搭建 10.6文章分页展示 10.7文章详情查看 10.8文章评论管理 10.9数据展示 10.10文章发布 10.11文章修改 10.12文章删除 10.13用户登录控制 10.14定时邮件发送 作者: 悟空非空也 链接: https://wukongnotnull.github.io/spring-boot-quickstart-wukongnote/integrated-project/integrated-project.html 来源: 悟空非空也 本文原创发布于「悟空非空也」,转载请注明出处,谢谢合作! © 悟空非空也 all right reserved，powered by Gitbook文件修订时间: 2021-07-26 09:01:22 "}}